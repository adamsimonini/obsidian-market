This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
.github/
  ISSUE_TEMPLATE/
    bug-report---.md
    feature-request---.md
aleo/
  src/
    main.leo
  tests/
    test_leo.leo
  program.json
  testing.md
backend/
  .vscode/
    extensions.json
    settings.json
  supabase/
    migrations/
      20251119000405_initual_schema.sql
    .gitignore
    config.toml
    seed.sql
  SUPABASE_CLI.md
business/
  odds-logic.md
  research.md
docs/
  aleo-local-dev.md
  database-upgrades.md
  deployment.md
  development.md
  orm-vs-supabase.md
  supabase-dependency-analysis.md
  supabase-schema.md
  supabase-setup.md
frontend/
  src/
    app/
      account/
        page.tsx
      settings/
        page.tsx
      globals.css
      layout.tsx
      page.tsx
    components/
      layout/
        Navbar.tsx
        Providers.tsx
      ui/
        badge.tsx
        button.tsx
        card.tsx
        dialog.tsx
        input.tsx
        sonner.tsx
      BetForm.tsx
      CreateMarketForm.tsx
      MarketCard.tsx
      MarketList.tsx
      WalletButton.tsx
    contexts/
      WalletContext.tsx
    hooks/
      useAdmin.ts
      useMarkets.ts
      useWallet.ts
    lib/
      supabase.ts
      utils.ts
    types/
      supabase.ts
  .gitignore
  .npmrc
  components.json
  eslint.config.mjs
  next.config.ts
  package.json
  postcss.config.mjs
  README.md
  tsconfig.json
.gitignore
CHANGELOG.md
CLAUDE.md
LICENSE.txt
package.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(leo --version:*)",
      "WebFetch(domain:docs.polymarket.com)",
      "Bash(xargs basename:*)",
      "Bash(ls:*)",
      "WebSearch",
      "WebFetch(domain:www.npmjs.com)",
      "WebFetch(domain:github.com)",
      "WebFetch(domain:developer.aleo.org)",
      "Bash(git checkout:*)",
      "Bash(npx create-next-app:*)",
      "Bash(npx shadcn@latest init:*)",
      "Bash(npm install:*)",
      "Bash(npx shadcn@latest add:*)",
      "Bash(npm run build:*)",
      "WebFetch(domain:aleo-dev-toolkit-react-app.vercel.app)",
      "WebFetch(domain:docs.leo.app)",
      "Bash(npm info:*)",
      "Bash(npm uninstall:*)",
      "Bash(git -C /Users/ajsim/code/aleo/obsidian-market status)",
      "Bash(git -C /Users/ajsim/code/aleo/obsidian-market diff --stat)",
      "Bash(git -C /Users/ajsim/code/aleo/obsidian-market log --oneline -5)",
      "Bash(git -C /Users/ajsim/code/aleo/obsidian-market add CLAUDE.md aleo/ frontend/.npmrc frontend/.gitignore frontend/components.json frontend/eslint.config.mjs frontend/next.config.ts frontend/postcss.config.mjs frontend/src/ frontend/README.md frontend/package.json frontend/package-lock.json frontend/tsconfig.json package.json)",
      "Bash(git -C /Users/ajsim/code/aleo/obsidian-market add frontend/app.json frontend/app/ frontend/babel.config.js frontend/components/ frontend/contexts/ frontend/eas.json frontend/eslint.config.js frontend/global.css frontend/hooks/ frontend/lib/ frontend/metro.config.js frontend/nativewind-env.d.ts frontend/pnpm-lock.yaml frontend/scripts/ frontend/tailwind.config.js frontend/theme/ frontend/types/ frontend/.vscode/)",
      "Bash(git -C /Users/ajsim/code/aleo/obsidian-market diff --cached --stat)",
      "Bash(git -C /Users/ajsim/code/aleo/obsidian-market commit -m \"$\\(cat <<''EOF''\nMigrate frontend from React Native \\(Expo\\) to Next.js\n\nReplace the Expo 54 / React Native frontend with a Next.js 16 App Router\nweb app using shadcn/ui + Tailwind CSS v4. Swap wallet adapter from\n@demox-labs to @provablehq packages.\n\n- Scaffold Next.js with TypeScript, Tailwind v4, shadcn/ui \\(new-york\\)\n- Port Obsidian Market theme colors \\(light blue/dark green\\) to oklch format\n- Migrate all components: MarketList, MarketCard, BetForm, CreateMarketForm\n- Replace tab navigation with top Navbar using next/link\n- Simplify WalletContext using @provablehq/aleo-wallet-adaptor-react\n- Add next-themes for dark/light mode toggling\n- Preserve Supabase real-time subscriptions and admin hooks\n- Move leo/ contract files to aleo/ directory\n- Update CLAUDE.md and root package.json scripts\n\nCo-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>\nEOF\n\\)\")",
      "Bash(git -C /Users/ajsim/code/aleo/obsidian-market push -u origin nextjs-migration)",
      "Bash(git -C /Users/ajsim/code/aleo/obsidian-market log master..HEAD --oneline)",
      "Bash(git -C /Users/ajsim/code/aleo/obsidian-market diff master...HEAD --stat)",
      "Bash(gh pr create:*)",
      "Bash(brew list:*)",
      "Bash(brew install:*)",
      "Bash(gh auth login:*)"
    ]
  }
}
</file>

<file path=".github/ISSUE_TEMPLATE/bug-report---.md">
---
name: "Bug report \U0001F41E"
about: Create a bug report
labels: bug

---

## Describe the bug
A clear and concise description of what the bug is.

### Steps to reproduce
Steps to reproduce the behavior.

### Expected behavior
A clear and concise description of what you expected to happen.

### Environment
 - OS: [e.g. Arch Linux]
 - Other details that you think may affect.

### Additional context
Add any other context about the problem here.
</file>

<file path=".github/ISSUE_TEMPLATE/feature-request---.md">
---
name: "Feature request \U0001F680"
about: Suggest an idea
labels: enhancement

---

## Summary
Brief explanation of the feature.

### Basic example
Include a basic example or links here.

### Motivation
Why are we doing this? What use cases does it support? What is the expected outcome?
</file>

<file path="aleo/src/main.leo">
// The 'leo' program.
program obsidian_market.aleo {
    // For more information, please refer to the documentation: `https://docs.leo-lang.org/guides/upgradability`
    @admin(address="aleo1awc7l4v56ahsjyj29g4fe3f8ps4w3akzy305vymlzm3exawgvypqk78elv")
    async constructor() {}

    // Market status: 0 = open, 1 = closed, 2 = resolved, 3 = cancelled
    // Market struct structure (structs can be stored in mappings)
    struct Market {
        id: u64,
        creator: address,
        market_type: u8,  // 1 = cpmm
        yes_reserves: u64,  // PUBLIC - required for pricing
        no_reserves: u64,   // PUBLIC - required for pricing
        status: u8,
    }

    // Private record for bet positions (users hold these privately)
    // No public bet tracking - maximum privacy
    record BetRecord {
        owner: address,
        market_id: u64,
        shares: u64,
        side: bool,  // true = Yes, false = No
    }

    // Mappings to store market data
    mapping markets: u64 => Market;
    mapping market_counter: u64 => u64;

    // Constants
    const MARKET_STATUS_OPEN: u8 = 0u8;
    const MARKET_STATUS_CLOSED: u8 = 1u8;
    const MARKET_STATUS_RESOLVED: u8 = 2u8;
    const MARKET_STATUS_CANCELLED: u8 = 3u8;
    const MIN_BET_AMOUNT: u64 = 1000000u64; // 1 ALEO in microcredits
    

    // Create a new market (admin only)
    // Must be async to write to mappings
    async transition create_market(
        public market_id: u64,
        public yes_odds: u64,
        public no_odds: u64
    ) -> Future {
        // Validate admin (caller must be admin)
        // Note: In production, you'd check against an admin list
        // For MVP, we'll use the program admin address
        let caller: address = self.caller;
        
        // Create new market struct
        // For CPMM: yes_odds and no_odds are initial reserves (liquidity)
        let market: Market = Market {
            id: market_id,
            creator: caller,
            market_type: 1u8,  // 1 = CPMM market type
            yes_reserves: yes_odds,  // Initial YES reserve (liquidity)
            no_reserves: no_odds,    // Initial NO reserve (liquidity)
            status: MARKET_STATUS_OPEN,
        };

        // Store market in mapping (must use .set() in async function)
        return create_market_onchain(market_id, market);
    }

    // Async function to store market in mapping
    async function create_market_onchain(
        public market_id: u64,
        public market: Market
    ) {
        // Use .set() method for mappings, not array syntax
        markets.set(market_id, market);
    }

    // Note: Reading from mappings requires async functions, but async functions can't return values
    // For now, market data should be queried off-chain or passed as parameters
    // If you need to read markets, consider making reserves public parameters in transitions

    // Place a bet on a market
    // Returns Future for async public state update
    // Note: Market reserves are public (needed for AMM), so we pass them as public params
    async transition place_bet_cpmm(
        public market_id: u64,           // Public (needed to identify market)
        public current_yes_reserves: u64, // Public (market reserves are public for AMM)
        public current_no_reserves: u64,  // Public (market reserves are public for AMM)
        private amount: u64,             // PRIVATE - bet amount
        private side: bool,              // PRIVATE - user's bet direction hidden
    ) -> (BetRecord, Future) {
        // 1. Validate minimum bet amount
        assert(amount >= MIN_BET_AMOUNT);
        
        // 2. Calculate shares using CPMM formula (private computation)
        let (new_yes_reserves, new_no_reserves, shares_out) = calculate_cpmm_swap(
            current_yes_reserves,
            current_no_reserves,
            amount,
            side
        );
        
        // 3. Create a new bet record, which is a private record that represents the user's shares
        // All records belong to a user and are associated with a market
        let bet_record = BetRecord {
            market_id: market_id,
            owner: self.signer,  // Private - user's address (signer in private transitions)
            shares: shares_out,  // Private - shares they receive (not what they put in)
            side: side,          // Private - their bet direction
        };
        
        // 4. The async function will validate and update public reserves on-chain
        let future = update_market_reserves(
            market_id, 
            new_yes_reserves, 
            new_no_reserves,
            current_yes_reserves,  // For validation (prevents race conditions)
            current_no_reserves    // For validation (prevents race conditions)
        );
        
        return (bet_record, future);
    }

    // Calculate CPMM swap for binary market (Yes/No)
    // CPMM formula: x * y = k (constant product)
    // Returns: (new_yes_reserves, new_no_reserves, shares_out)
    function calculate_cpmm_swap(
        current_yes: u64,
        current_no: u64,
        amount_in: u64,
        side: bool  // true = betting Yes, false = betting No
    ) -> (u64, u64, u64) {
        // Calculate constant product k = x * y
        let k: u64 = current_yes * current_no;
        
        if side {
            // Betting on Yes: add amount to yes_reserves
            let new_yes: u64 = current_yes + amount_in;
            
            // Maintain constant product: k = new_yes * new_no
            // new_no = k / new_yes
            let new_no: u64 = k / new_yes;
            
            // Calculate shares received using CPMM formula
            // Shares = (amount_in * current_no) / new_yes
            let shares_out: u64 = (amount_in * current_no) / new_yes;
            
            return (new_yes, new_no, shares_out);
        } else {
            // Betting on No: add amount to no_reserves
            let new_no: u64 = current_no + amount_in;
            
            // Maintain constant product: k = new_yes * new_no
            // new_yes = k / new_no
            let new_yes: u64 = k / new_no;
            
            // Calculate shares received using CPMM formula
            // Shares = (amount_in * current_yes) / new_no
            let shares_out: u64 = (amount_in * current_yes) / new_no;
            
            return (new_yes, new_no, shares_out);
        }
    }

    // Async function to update PUBLIC reserves on-chain
    // Async functions don't return values - they execute side effects (mutations)
    async function update_market_reserves(
        public market_id: u64,
        public new_yes_reserves: u64,
        public new_no_reserves: u64,
        public expected_yes_reserves: u64,  // For validation (prevents race conditions)
        public expected_no_reserves: u64   // For validation (prevents race conditions)
    ) {
        // This executes on-chain after private transition proof is verified
        // Use .get_or_use() method for mappings, not .get()
        // Default market with id=0 indicates not found (can't use self.caller in async functions)
        // Use admin address as placeholder for default market
        let default_creator: address = aleo12jwjgr6uvlydcgjlguyhlp6rfgntnyx7hk5g8k5dllqpjtdngcqqcrhmfj;
        let default_market: Market = Market {
            id: 0u64,
            creator: default_creator,  // Placeholder (we check id != 0 to validate)
            market_type: 0u8,
            yes_reserves: 0u64,
            no_reserves: 0u64,
            status: 0u8,
        };
        let market: Market = markets.get_or_use(market_id, default_market);
        
        // Validate market exists and is open
        assert(market.id != 0u64);  // Market must exist
        assert(market.status == MARKET_STATUS_OPEN);  // Market must be open
        
        // Validate reserves match expected (prevents race conditions)
        assert(market.yes_reserves == expected_yes_reserves);
        assert(market.no_reserves == expected_no_reserves);
        
        // Update PUBLIC pool state with new reserves using .set() method
        markets.set(market_id, Market {
            id: market.id,  
            creator: market.creator,
            market_type: market.market_type,
            yes_reserves: new_yes_reserves,  // PUBLIC update
            no_reserves: new_no_reserves,    // PUBLIC update
            status: market.status,
        });
    }

}
</file>

<file path="aleo/tests/test_leo.leo">
import obsidian_market.aleo;

program test_leo.aleo {
    // Test market creation
    @test
    async transition test_create_market() -> Future {
        let market_id: u64 = 1u64;
        let yes_reserves: u64 = 50000000u64;
        let no_reserves: u64 = 50000000u64;

        let f: Future = obsidian_market.aleo/create_market(market_id, yes_reserves, no_reserves);
        return finalize_test_create_market(f);
    }

    async function finalize_test_create_market(f: Future) {
        f.await();
    }

    // Test placing a bet and verify the returned BetRecord
    @test
    async transition test_place_bet() -> Future {
        let market_id: u64 = 1u64;
        let yes_reserves: u64 = 50000000u64;
        let no_reserves: u64 = 50000000u64;

        // Create market first
        let create_future: Future = obsidian_market.aleo/create_market(market_id, yes_reserves, no_reserves);

        // Place a Yes bet
        let amount: u64 = 1000000u64; // 1 ALEO
        let side: bool = true;
        let (bet_record, bet_future): (obsidian_market.aleo/BetRecord, Future) = obsidian_market.aleo/place_bet_cpmm(
            market_id, yes_reserves, no_reserves, amount, side
        );

        // Verify bet record fields
        assert_eq(bet_record.market_id, market_id);
        assert_eq(bet_record.side, true);

        return finalize_test_place_bet(create_future, bet_future);
    }

    async function finalize_test_place_bet(create_future: Future, bet_future: Future) {
        create_future.await();
        bet_future.await();
    }

    // Test minimum bet validation - should fail with amount below MIN_BET_AMOUNT
    @test
    @should_fail
    transition test_minimum_bet() {
        let market_id: u64 = 1u64;
        let yes_reserves: u64 = 50000000u64;
        let no_reserves: u64 = 50000000u64;

        // Try to bet less than minimum (1 ALEO = 1000000 microcredits)
        let amount: u64 = 500000u64; // 0.5 ALEO - should fail at assert
        let side: bool = true;
        let (bet_record, bet_future): (obsidian_market.aleo/BetRecord, Future) = obsidian_market.aleo/place_bet_cpmm(
            market_id, yes_reserves, no_reserves, amount, side
        );
    }

    @admin(address="aleo1awc7l4v56ahsjyj29g4fe3f8ps4w3akzy305vymlzm3exawgvypqk78elv")
    async constructor() {}
}
</file>

<file path="aleo/program.json">
{
  "program": "obsidian_market.aleo",
  "version": "0.1.0",
  "description": "",
  "license": "Proprietary License",
  "leo": "3.3.1",
  "dependencies": null,
  "dev_dependencies": null
}
</file>

<file path="aleo/testing.md">
testnet deployment: https://testnet.explorer.provable.com/program/obsidian_market.aleo

# Testing

Once deployed, an application lives on the ledger forever. Consequently, it's important to consider every edge case and rigorously test your code.

## Tools & Techniques

- **Unit and Integration Testing** - Validate Leo program logic through test cases.
- **Running a Devnet** - Deploy and execute on a local devnet.
- **Deploying/Executing on Testnet** - Deploy and execute on the Aleo Testnet.

## Unit and Integration Testing

The Leo testing framework enables developers to validate their Leo program logic by writing unit and integration tests. Tests are written in Leo and are located in a `tests/` subdirectory of the main Leo project directory.

```
obsidian_market
â”œâ”€â”€ build/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.leo
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ test_leo.leo
â”œâ”€â”€ .env
â””â”€â”€ program.json
```

The test file is a Leo program that imports the program in `main.leo`. Test functions are annotated with `@test` above the function declaration.

> **Note:** The name of the test file must match the program name within that file. For example, `test_leo.leo` must contain `program test_leo.aleo`.

### Testing Transition Functions

```leo
@test
transition test_simple_addition() {
    let result: u32 = example_program.aleo/simple_addition(2u32, 3u32);
    assert_eq(result, 5u32);
}
```

The `@should_fail` annotation should be added after `@test` for tests that are expected to fail:

```leo
@test
@should_fail
transition test_simple_addition_fail() {
    let result: u32 = example_program.aleo/simple_addition(2u32, 3u32);
    assert_eq(result, 3u32);
}
```

### Testing Records

Record and struct fields can be validated in tests:

```leo
@test
transition test_record_maker() {
    let r: example_program.aleo/Example = example_program.aleo/mint_record(0field);
    assert_eq(r.x, 0field);
}
```

### Modeling On-Chain State with Scripts

The testing framework cannot access real on-chain state. Instead, use `script` tests to await Futures and interact with mappings directly:

```leo
@test
script test_async() {
    const VAL: field = 12field;
    let fut: Future = example_program.aleo/set_mapping(VAL);
    fut.await();
    assert_eq(Mapping::get(example_program.aleo/map, 0field), VAL);

    let rand_val: field = ChaCha::rand_field();
    Mapping::set(example_program.aleo/map, VAL, rand_val);
    let value: field = Mapping::get(example_program.aleo/map, VAL);
    assert_eq(value, rand_val);
}
```

> **Note:** External transitions (async or not) may be called from test transitions or scripts, but external async functions may only be called directly from scripts.

## Running Tests

```bash
# Run all tests
leo test

# Run a specific test by name
leo test test_async

# Run tests matching a substring
leo test addition
```

### Important: `@admin` and Private Key

`leo test` creates a local test ledger with pre-funded dev accounts. If your program uses `@admin`, the `@admin` address **must match** the private key used to run tests â€” otherwise deployment will fail with "Deployment transaction not accepted."

The recommended dev key for testing:

- **Private Key:** `APrivateKey1zkp8CZNn3yeCseEtxuVPbDCwSyhGW6yZKUYKfgXmcpoGPWH`
- **Address:** `aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px`

You can override the key used for tests:

```bash
leo test --private-key APrivateKey1zkp8CZNn3yeCseEtxuVPbDCwSyhGW6yZKUYKfgXmcpoGPWH
```

## Running a Local Devnet

For deployment and execution testing, use amareleo-chain (lightweight single-node devnet):

```bash
# Start (in-memory, state lost on stop)
amareleo-chain start

# Start with persistent state
amareleo-chain start --keep-state
```

Or use `leo devnet` (heavier, requires 4 validators minimum):

```bash
leo devnet start --num-validators 4 --num-clients 0
```
</file>

<file path="backend/.vscode/extensions.json">
{
  "recommendations": ["denoland.vscode-deno"]
}
</file>

<file path="backend/.vscode/settings.json">
{
  "deno.enablePaths": [
    "supabase/functions"
  ],
  "deno.lint": true,
  "deno.unstable": [
    "bare-node-builtins",
    "byonm",
    "sloppy-imports",
    "unsafe-proto",
    "webgpu",
    "broadcast-channel",
    "worker-options",
    "cron",
    "kv",
    "ffi",
    "fs",
    "http",
    "net"
  ],
  "[typescript]": {
    "editor.defaultFormatter": "denoland.vscode-deno"
  }
}
</file>

<file path="backend/supabase/migrations/20251119000405_initual_schema.sql">
create table "public"."admins" (
    "wallet_address" text not null,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."admins" enable row level security;


  create table "public"."markets" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "title" text not null,
    "description" text,
    "resolution_rules" text not null,
    "resolution_source" text not null,
    "resolution_deadline" timestamp with time zone not null,
    "status" text not null,
    "yes_odds" numeric(10,2) not null,
    "no_odds" numeric(10,2) not null,
    "creator_address" text not null,
    "market_id_onchain" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."markets" enable row level security;

CREATE UNIQUE INDEX admins_pkey ON public.admins USING btree (wallet_address);

CREATE INDEX idx_markets_created_at ON public.markets USING btree (created_at DESC);

CREATE INDEX idx_markets_market_id_onchain ON public.markets USING btree (market_id_onchain);

CREATE INDEX idx_markets_status ON public.markets USING btree (status);

CREATE UNIQUE INDEX markets_market_id_onchain_key ON public.markets USING btree (market_id_onchain);

CREATE UNIQUE INDEX markets_pkey ON public.markets USING btree (id);

alter table "public"."admins" add constraint "admins_pkey" PRIMARY KEY using index "admins_pkey";

alter table "public"."markets" add constraint "markets_pkey" PRIMARY KEY using index "markets_pkey";

alter table "public"."markets" add constraint "markets_market_id_onchain_key" UNIQUE using index "markets_market_id_onchain_key";

alter table "public"."markets" add constraint "markets_no_odds_check" CHECK ((no_odds > (0)::numeric)) not valid;

alter table "public"."markets" validate constraint "markets_no_odds_check";

alter table "public"."markets" add constraint "markets_status_check" CHECK ((status = ANY (ARRAY['open'::text, 'closed'::text, 'resolved'::text, 'cancelled'::text]))) not valid;

alter table "public"."markets" validate constraint "markets_status_check";

alter table "public"."markets" add constraint "markets_yes_odds_check" CHECK ((yes_odds > (0)::numeric)) not valid;

alter table "public"."markets" validate constraint "markets_yes_odds_check";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$function$
;

grant delete on table "public"."admins" to "anon";

grant insert on table "public"."admins" to "anon";

grant references on table "public"."admins" to "anon";

grant select on table "public"."admins" to "anon";

grant trigger on table "public"."admins" to "anon";

grant truncate on table "public"."admins" to "anon";

grant update on table "public"."admins" to "anon";

grant delete on table "public"."admins" to "authenticated";

grant insert on table "public"."admins" to "authenticated";

grant references on table "public"."admins" to "authenticated";

grant select on table "public"."admins" to "authenticated";

grant trigger on table "public"."admins" to "authenticated";

grant truncate on table "public"."admins" to "authenticated";

grant update on table "public"."admins" to "authenticated";

grant delete on table "public"."admins" to "postgres";

grant insert on table "public"."admins" to "postgres";

grant references on table "public"."admins" to "postgres";

grant select on table "public"."admins" to "postgres";

grant trigger on table "public"."admins" to "postgres";

grant truncate on table "public"."admins" to "postgres";

grant update on table "public"."admins" to "postgres";

grant delete on table "public"."admins" to "service_role";

grant insert on table "public"."admins" to "service_role";

grant references on table "public"."admins" to "service_role";

grant select on table "public"."admins" to "service_role";

grant trigger on table "public"."admins" to "service_role";

grant truncate on table "public"."admins" to "service_role";

grant update on table "public"."admins" to "service_role";

grant delete on table "public"."markets" to "anon";

grant insert on table "public"."markets" to "anon";

grant references on table "public"."markets" to "anon";

grant select on table "public"."markets" to "anon";

grant trigger on table "public"."markets" to "anon";

grant truncate on table "public"."markets" to "anon";

grant update on table "public"."markets" to "anon";

grant delete on table "public"."markets" to "authenticated";

grant insert on table "public"."markets" to "authenticated";

grant references on table "public"."markets" to "authenticated";

grant select on table "public"."markets" to "authenticated";

grant trigger on table "public"."markets" to "authenticated";

grant truncate on table "public"."markets" to "authenticated";

grant update on table "public"."markets" to "authenticated";

grant delete on table "public"."markets" to "postgres";

grant insert on table "public"."markets" to "postgres";

grant references on table "public"."markets" to "postgres";

grant select on table "public"."markets" to "postgres";

grant trigger on table "public"."markets" to "postgres";

grant truncate on table "public"."markets" to "postgres";

grant update on table "public"."markets" to "postgres";

grant delete on table "public"."markets" to "service_role";

grant insert on table "public"."markets" to "service_role";

grant references on table "public"."markets" to "service_role";

grant select on table "public"."markets" to "service_role";

grant trigger on table "public"."markets" to "service_role";

grant truncate on table "public"."markets" to "service_role";

grant update on table "public"."markets" to "service_role";


  create policy "Admins list is viewable by everyone"
  on "public"."admins"
  as permissive
  for select
  to public
using (true);



  create policy "Anyone can add admins"
  on "public"."admins"
  as permissive
  for insert
  to public
with check (true);



  create policy "Anyone can create markets"
  on "public"."markets"
  as permissive
  for insert
  to public
with check (true);



  create policy "Anyone can update markets"
  on "public"."markets"
  as permissive
  for update
  to public
using (true);



  create policy "Markets are viewable by everyone"
  on "public"."markets"
  as permissive
  for select
  to public
using (true);


CREATE TRIGGER update_markets_updated_at BEFORE UPDATE ON public.markets FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
</file>

<file path="backend/supabase/.gitignore">
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
</file>

<file path="backend/supabase/seed.sql">
-- Seed data for Obsidian Market
-- This file is automatically run when you execute `supabase db reset`
-- Or manually run with: supabase db execute --file supabase/seed.sql

-- Insert admin wallet addresses
INSERT INTO public.admins (wallet_address) VALUES
    ('aleo12jwjgr6uvlydcgjlguyhlp6rfgntnyx7hk5g8k5dllqpjtdngcqqcrhmfj')
ON CONFLICT (wallet_address) DO NOTHING;

-- Insert example markets
INSERT INTO public.markets (
    title,
    description,
    resolution_rules,
    resolution_source,
    resolution_deadline,
    status,
    yes_odds,
    no_odds,
    creator_address,
    market_id_onchain
) VALUES
    (
        'Will Bitcoin reach $150,000 by end of 2026?',
        'This market resolves based on whether Bitcoin (BTC) reaches or exceeds $150,000 USD by December 31, 2026 at 11:59 PM UTC.',
        'Market resolves to YES if Bitcoin (BTC) price reaches or exceeds $150,000 USD at any point before December 31, 2026 11:59 PM UTC, as reported by CoinGecko. Market resolves to NO otherwise.',
        'CoinGecko API (https://www.coingecko.com/en/api)',
        '2026-12-31T23:59:59Z',
        'open',
        2.50,
        1.67,
        'aleo1qg23nrrrlf6h7fqq7amk9wqzs06sluh7tm5y6lgg9svpqpck0qqqv9h0sw',
        NULL
    ),
    (
        'Will the US Federal Reserve cut interest rates by at least 0.5% in 2025?',
        'This market resolves based on whether the US Federal Reserve reduces the federal funds rate by at least 0.5 percentage points (50 basis points) at any point during calendar year 2025.',
        'Market resolves to YES if the Federal Reserve announces a rate cut of at least 0.5% (50 basis points) during 2025, as reported by official Fed announcements. Multiple smaller cuts that sum to 0.5% or more also count. Market resolves to NO if total cuts are less than 0.5% or if rates increase.',
        'Federal Reserve official announcements and FOMC statements',
        '2025-12-31T23:59:59Z',
        'open',
        1.80,
        2.00,
        'aleo1qg23nrrrlf6h7fqq7amk9wqzs06sluh7tm5y6lgg9svpqpck0qqqv9h0sw',
        NULL
    ),
    (
        'Will AI-generated content be regulated by the EU before 2027?',
        'This market resolves based on whether the European Union passes and enforces comprehensive legislation specifically regulating AI-generated content (including deepfakes, synthetic media, and AI-authored content) before January 1, 2027.',
        'Market resolves to YES if the EU passes binding legislation that specifically regulates AI-generated content and it comes into effect before 2027. The regulation must be EU-wide (not just individual member states) and must specifically address AI-generated content. Market resolves to NO if no such regulation is in effect by the deadline.',
        'Official EU legislation database (EUR-Lex) and European Commission announcements',
        '2026-12-31T23:59:59Z',
        'open',
        1.50,
        2.50,
        'aleo1qg23nrrrlf6h7fqq7amk9wqzs06sluh7tm5y6lgg9svpqpck0qqqv9h0sw',
        NULL
    )
ON CONFLICT DO NOTHING;
</file>

<file path="business/odds-logic.md">
# Odds Logic: Fixed Odds vs CPMM Transition Analysis

## Executive Summary

**Short Answer**: Yes, you can implement fixed odds first and transition to CPMM later, but there will be **moderate technical debt** that can be minimized with careful architecture. The transition is **feasible** but requires planning.

**Update**: After analysis, **AMM/CPMM is feasible on Aleo** using a hybrid public/private architecture. Pool reserves can be PUBLIC (enabling AMM functionality) while individual bets remain PRIVATE (maintaining user privacy).

**Recommendation**: Start with CPMM/AMM from the beginning if you want crypto-native data. The hybrid privacy model (public pools, private bets) is actually a competitive advantage.

---

## AMM Feasibility on Aleo: Privacy Analysis

### The Critical Question

**"Given that Aleo is privacy-preserving, is it even possible to have AMM? Can't people shield their data preventing this?"**

### âœ… **Answer: YES, AMM is feasible on Aleo**

Aleo supports **both public and private state**, enabling a hybrid architecture where:
- **Pool reserves are PUBLIC** (required for AMM pricing)
- **Individual bets are PRIVATE** (maintains user privacy)

---

### How Aleo's Public/Private State Works

#### 1. **Public Mappings** (What AMM Needs)

In Aleo, mappings can be **publicly queryable**:

```leo
// Public mapping - anyone can query
mapping markets: u64 => Market;

// Market struct with PUBLIC pool reserves
struct Market {
    id: u64,
    creator: address,
    market_type: u8,  // 1 = cpmm
    yes_reserves: u64,  // PUBLIC - required for pricing
    no_reserves: u64,   // PUBLIC - required for pricing
    status: u8,
}

// Public transition - anyone can call
transition get_market(public market_id: u64) -> Market {
    let market: Market = markets.get(market_id);
    return market;  // Returns PUBLIC data
}
```

**Key Point**: The `markets` mapping is **publicly accessible**. Anyone can query `markets[market_id]` to get current `yes_reserves` and `no_reserves`, enabling:
- âœ… Real-time price calculation
- âœ… Slippage calculation
- âœ… Liquidity depth visibility
- âœ… AMM functionality

#### 2. **Private Transactions with Records** (What Users Want)

Individual bet transactions can remain **private** using Aleo's record system, but updating public state requires **async transitions**:

**How Records Work:**
1. **User spends a credit record** - Consumes their private record containing credits (value)
2. **User receives a new record** - Gets a new private record representing their shares/position
3. **Public mapping updated** - Pool reserves (for CPMM) or bet totals are updated publicly

```leo
// Record structure (simplified)
record BetRecord {
    owner: address,      // Private - who owns this bet
    market_id: u64,     // Private - which market
    shares: u64,        // Private - how many shares
    side: bool,         // Private - Yes or No
}

// Private transition - bet details are hidden
// Consumes credit record, creates bet record, returns Future
transition place_bet_cpmm(
    public market_id: u64,           // Public (needed to identify market)
    credit_record: credits.aleo/credits.record,  // PRIVATE - user's credit record to spend
    private side: bool,               // PRIVATE - user's bet direction hidden
) -> (BetRecord, Future) {
    // 1. Extract amount from credit record (private)
    let amount = credit_record.microcredits;
    
    // 2. Get current PUBLIC reserves (can read public state)
    let market: Market = markets.get(market_id);
    let current_yes = market.yes_reserves;
    let current_no = market.no_reserves;
    
    // 3. Calculate shares using CPMM formula (private computation)
    let (new_yes_reserves, new_no_reserves, shares_out) = calculate_cpmm_swap(
        current_yes,
        current_no,
        amount,
        side
    );
    
    // 4. Create new PRIVATE record for user (represents their shares)
    let bet_record = BetRecord {
        owner: self.caller,  // Private - user's address
        market_id: market_id,
        shares: shares_out,  // Private - their share amount
        side: side,          // Private - their bet direction
    };
    
    // 5. Return Future for async public state update
    // The async function will update public reserves on-chain
    let future = update_market_reserves(market_id, new_yes_reserves, new_no_reserves);
    
    return (bet_record, future);
}

// Async function to update PUBLIC pool state on-chain
async function update_market_reserves(
    market_id: u64,
    new_yes_reserves: u64,
    new_no_reserves: u64
) -> Market {
    // This executes on-chain after private transition proof is verified
    let market: Market = markets.get(market_id);
    
    // Update PUBLIC pool state
    markets[market_id] = Market {
        yes_reserves: new_yes_reserves,  // PUBLIC update
        no_reserves: new_no_reserves,    // PUBLIC update
        ...
    };
    
    return markets[market_id];
}
```

**Key Points**: 
- **Records are required** - Private transitions must consume and create records
- **User spends credit record** - Their credits are consumed to place the bet
- **User receives bet record** - New private record represents their position/shares
- **Public mapping updated** - Pool reserves updated via Future/async (for CPMM)
- **Transaction details private** - Amount, side, user identity hidden in records
- **Pool state public** - Reserves visible for AMM pricing

---

### Important: Async/Future Pattern for Private â†’ Public State Updates

**Critical Architecture Point**: In Aleo, when a transition has **private parameters** and needs to update **public state** (like public mappings), you **must use async transitions and Future objects**.

#### How It Works

1. **Private Transition** (executes off-chain):
   - Has private parameters (bet amount, side)
   - Performs private computation
   - Returns a `Future` object (not the final result)

2. **Async Function** (executes on-chain):
   - Receives the Future
   - Updates public state (mappings)
   - Executes after network verifies the private transition proof

3. **Future Object**:
   - Bridges private off-chain execution with public on-chain state
   - Ensures privacy while allowing necessary public updates

#### Why This Is Required

- **Private transitions** execute off-chain to preserve confidentiality
- **Public state updates** require on-chain consensus
- **Future objects** bridge these two worlds asynchronously

#### Alternative: Fully Public Transitions

If you want to avoid async complexity, you can make all parameters public:

```leo
// Fully public - simpler but less private
transition place_bet_cpmm_public(
    public market_id: u64,
    public side: bool,      // PUBLIC - visible on-chain
    public amount: u64       // PUBLIC - visible on-chain
) -> Market {
    // Can directly update public mappings synchronously
    let market: Market = markets.get(market_id);
    // ... update logic ...
    markets[market_id] = updated_market;
    return markets[market_id];
}
```

**Trade-off**: Simpler code, but bet details are public (like Polymarket).

#### Privacy vs Complexity Trade-off

| Approach | Privacy Level | Code Complexity | Performance |
|----------|--------------|-----------------|-------------|
| **Fully Private** (async/Future) | ðŸŸ¢ HIGH - Bet details hidden | ðŸ”´ HIGH - Async pattern required | ðŸŸ¡ MEDIUM - Off-chain + on-chain |
| **Partially Public** (public side/amount) | ðŸŸ¡ MEDIUM - Bet details visible | ðŸŸ¢ LOW - Synchronous updates | ðŸŸ¢ HIGH - Direct on-chain |
| **Fully Public** (all public) | ðŸ”´ LOW - Everything visible | ðŸŸ¢ LOW - Simplest | ðŸŸ¢ HIGH - Direct on-chain |

**Recommendation**: 
- For **maximum privacy**: Use async/Future pattern (more complex)
- For **simpler implementation**: Make `side` and `amount` public (still more private than Polymarket since user identity can be hidden)
- **Hybrid approach**: Make `side` public (needed for CPMM anyway), keep `amount` private (if possible)

**Note for CPMM**: The CPMM calculation requires knowing which side (YES/NO) to update the correct reserve. The private transition can calculate new reserves privately, then the async function applies those reserves. The Future object can contain the calculated new reserves without revealing the private input amount.

**Example Future Structure**:
```leo
// Future contains public outputs (new reserves) without revealing private inputs
Future {
    market_id: u64,           // Public
    new_yes_reserves: u64,     // Public (calculated privately)
    new_no_reserves: u64,      // Public (calculated privately)
    // Private inputs (amount, side) are NOT in Future
}
```

---

### Hybrid Privacy Model: Public Pools, Private Bets

### Hybrid Privacy Model: Public Pools, Private Bets

#### What's Public (Required for AMM)

1. **Pool Reserves**: `yes_reserves`, `no_reserves`
   - Needed for: Price calculation, slippage, liquidity depth
   - Visibility: Anyone can query

2. **Market Metadata**: Market ID, status, creator
   - Needed for: Market identification, UI display
   - Visibility: Public

3. **Aggregate Statistics**: Total volume, number of bets (optional)
   - Needed for: Analytics, trending markets
   - Visibility: Public (if tracked)

#### What's Private (User Privacy)

1. **Individual Bet Amounts**: How much each user bet
   - Privacy: Hidden via zero-knowledge proofs
   - Benefit: Users can't be tracked by bet size

2. **Bet Direction**: Whether user bet Yes or No
   - Privacy: Hidden via zero-knowledge proofs
   - Benefit: Trading strategies remain private

3. **User Identity**: Who placed each bet
   - Privacy: Hidden via zero-knowledge proofs
   - Benefit: No on-chain address linking

4. **User Balances**: Individual share holdings
   - Privacy: Stored as private records
   - Benefit: Financial privacy maintained

---

### Example: CPMM on Aleo

```leo
program obsidian_market.aleo {
    // PUBLIC mapping - pool reserves visible to all
    mapping markets: u64 => Market;
    
    // PUBLIC struct - reserves are public
    struct Market {
        id: u64,
        creator: address,
        market_type: u8,  // 1 = cpmm
        yes_reserves: u64,  // PUBLIC
        no_reserves: u64,   // PUBLIC
        status: u8,
    }
    
    // PRIVATE bet placement - requires async for public state updates
    transition place_bet_cpmm(
        public market_id: u64,
        private user_amount: u64,  // PRIVATE
        private side: bool           // PRIVATE
    ) -> Future {
        // Get current PUBLIC reserves (can read public state)
        let market: Market = markets.get(market_id);
        let current_yes = market.yes_reserves;
        let current_no = market.no_reserves;
        
        // Calculate new reserves using CPMM (x * y = k)
        // This happens privately off-chain
        let (new_yes, new_no, shares_out) = calculate_cpmm_swap(
            current_yes,
            current_no,
            user_amount,
            side
        );
        
        // Return Future for async public state update
        // The async function will update public reserves on-chain
        return update_market_reserves(market_id, new_yes, new_no);
    }
    
    // Async function to update PUBLIC pool state on-chain
    async function update_market_reserves(
        market_id: u64,
        new_yes_reserves: u64,
        new_no_reserves: u64
    ) -> Market {
        // This executes on-chain after private transition proof is verified
        let market: Market = markets.get(market_id);
        
        // Update PUBLIC pool state
        markets[market_id] = Market {
            yes_reserves: new_yes_reserves,  // PUBLIC update
            no_reserves: new_no_reserves,    // PUBLIC update
            ...
        };
        
        return markets[market_id];
    }
    
    // PUBLIC query - anyone can get current price
    transition get_market_price(public market_id: u64) -> (u64, u64) {
        let market: Market = markets.get(market_id);
        // Calculate price from PUBLIC reserves
        let yes_price = market.no_reserves / (market.yes_reserves + market.no_reserves);
        let no_price = market.yes_reserves / (market.yes_reserves + market.no_reserves);
        return (yes_price, no_price);
    }
}
```

---

### Privacy Comparison: Fixed Odds vs CPMM on Aleo

#### Fixed Odds (Current Implementation)

**Public:**
- âœ… Market odds (`yes_odds`, `no_odds`)
- âœ… Market totals (`total_yes_bets`, `total_no_bets`)
- âŒ Individual bet amounts (can be private)
- âŒ Individual bet directions (can be private)

**Private:**
- âœ… Individual bet amounts (if using private transitions)
- âœ… Individual bet directions (if using private transitions)
- âœ… User identities

**Privacy Level**: ðŸŸ¢ **HIGH** - Both odds and individual bets can be private

#### CPMM/AMM (Proposed)

**Public:**
- âœ… Pool reserves (`yes_reserves`, `no_reserves`) - **REQUIRED for AMM**
- âœ… Current price/probability (derived from reserves)
- âœ… Liquidity depth
- âŒ Individual bet amounts (PRIVATE)
- âŒ Individual bet directions (PRIVATE)

**Private:**
- âœ… Individual bet amounts (via private transitions)
- âœ… Individual bet directions (via private transitions)
- âœ… User identities
- âœ… Individual share holdings

**Privacy Level**: ðŸŸ¡ **MEDIUM-HIGH** - Pool state is public (required), but individual bets are private

---

### Competitive Advantage: Hybrid Privacy Model

#### What Makes This Unique

1. **More Private Than Polymarket**
   - Polymarket: All trades are PUBLIC on-chain
   - Obsidian Market: Individual bets are PRIVATE, only pool state is public

2. **More Functional Than Fully Private**
   - Fully private: Can't have AMM (no pricing mechanism)
   - Obsidian Market: AMM works (public pools) + user privacy (private bets)

3. **Best of Both Worlds**
   - âœ… AMM functionality (dynamic pricing, liquidity pools)
   - âœ… User privacy (bet amounts, directions, identities hidden)
   - âœ… Crypto-native (on-chain reserves, verifiable)

---

### Implementation Strategy

#### Option 1: Start with CPMM (Recommended)

**Pros:**
- Crypto-native from day one
- No transition technical debt
- Leverages Aleo's hybrid privacy model
- Competitive advantage (private bets + public pools)

**Cons:**
- More complex than fixed odds
- Requires liquidity providers
- More complex UX (slippage, dynamic pricing)

**Architecture:**
```leo
struct Market {
    id: u64,
    creator: address,
    market_type: u8,  // Always 1 = cpmm
    yes_reserves: u64,  // PUBLIC
    no_reserves: u64,   // PUBLIC
    status: u8,
}

// Private bet placement
transition place_bet(
    public market_id: u64,
    private amount: u64,  // PRIVATE
    private side: bool     // PRIVATE
) -> Shares {
    // CPMM logic with public pool updates
}
```

#### Option 2: Start with Fixed Odds, Add CPMM Later

**Pros:**
- Simpler MVP
- Faster to market
- Learn from users first

**Cons:**
- Technical debt (as analyzed above)
- Need to support both systems
- Migration complexity

---

### Final Verdict: AMM Feasibility

#### âœ… **YES, AMM is fully feasible on Aleo**

**Key Points:**

1. **Aleo supports public state** - Pool reserves can be public mappings
2. **AMM requires public pools** - This is compatible with Aleo
3. **Bets can remain private** - Individual transactions use private parameters
4. **Hybrid model is competitive** - More private than Polymarket, more functional than fully private

**Architecture:**
- **Public**: Pool reserves (`yes_reserves`, `no_reserves`) â†’ Enables AMM
- **Private**: Individual bets (amount, side, user) â†’ Maintains privacy

**This is actually a competitive advantage**: You get AMM functionality (like Polymarket) while maintaining user privacy (unlike Polymarket).

---

### Recommendation Update

Given the feasibility analysis:

**If you want crypto-native data and AMM functionality:**
- âœ… **Start with CPMM from the beginning**
- âœ… Use hybrid privacy model (public pools, private bets)
- âœ… This is your competitive advantage

**If you want simplicity and speed:**
- âœ… Start with fixed odds
- âœ… Add CPMM later (with technical debt)
- âœ… Use hybrid privacy model when adding CPMM

**The hybrid privacy model (public pools, private bets) works for both approaches.**

---

## Current Architecture Analysis

### On-Chain (Aleo Smart Contract)

**Current Market Struct:**
```leo
struct Market {
    id: u64,
    creator: address,
    yes_odds: u64,           // Fixed odds for Yes
    no_odds: u64,            // Fixed odds for No
    status: u8,
    total_yes_bets: u64,      // Sum of all Yes bets
    total_no_bets: u64,       // Sum of all No bets
}
```

**Current Bet Struct:**
```leo
struct Bet {
    market_id: u64,
    user: address,
    amount: u64,              // Bet amount
    side: bool,               // true = Yes, false = No
}
```

**Key Functions:**
- `create_market(market_id, yes_odds, no_odds)` - Admin sets fixed odds
- `place_bet(market_id, side, amount)` - Simple bet placement
- Payout calculation: `bet_amount Ã— odds` (fixed)

### Off-Chain (Supabase Database)

**Current Markets Table:**
```sql
CREATE TABLE markets (
    yes_odds NUMERIC(10,2) NOT NULL,  -- Fixed odds
    no_odds NUMERIC(10,2) NOT NULL,   -- Fixed odds
    ...
)
```

**Current Frontend Logic:**
- Displays fixed odds from `market.yes_odds` and `market.no_odds`
- Calculates payout: `amount * odds`
- Simple, predictable UX

---

## CPMM Requirements

### What CPMM Needs

**On-Chain:**
- `yes_reserves: u64` - Liquidity pool for YES shares
- `no_reserves: u64` - Liquidity pool for NO shares
- `total_liquidity: u64` - Total liquidity (optional, for LP tracking)
- Constant product formula: `x * y = k`
- Slippage calculation on each trade
- Dynamic pricing based on reserves

**Off-Chain:**
- Historical reserve snapshots for price charts
- Timestamp + yes_reserves + no_reserves
- Derived percentages: `yes_percentage = no_reserves / (yes_reserves + no_reserves)`

**Frontend:**
- Real-time price updates as reserves change
- Slippage warnings
- Liquidity depth visualization
- More complex UX

---

## Technical Debt Analysis

### ðŸ”´ High Technical Debt Areas

#### 1. **Smart Contract Architecture**

**Problem**: The `Market` struct is fundamentally different:
- Fixed odds: `yes_odds`, `no_odds` (static values)
- CPMM: `yes_reserves`, `no_reserves` (dynamic values)

**Impact**: 
- Cannot simply extend the struct - need to redesign
- Existing markets with fixed odds cannot coexist with CPMM markets easily
- Contract upgrade required (Aleo programs are upgradeable but need careful migration)

**Mitigation Strategy**:
```leo
// Option 1: Market Type Enum
struct Market {
    id: u64,
    creator: address,
    market_type: u8,  // 0 = fixed_odds, 1 = cpmm
    // Fixed odds fields (if market_type == 0)
    yes_odds: u64,
    no_odds: u64,
    // CPMM fields (if market_type == 1)
    yes_reserves: u64,
    no_reserves: u64,
    total_liquidity: u64,
    status: u8,
    total_yes_bets: u64,  // Keep for both (useful for CPMM too)
    total_no_bets: u64,
}
```

**Debt Level**: ðŸ”´ **HIGH** - Requires contract redesign and migration

#### 2. **Bet Placement Logic**

**Problem**: Completely different bet mechanics:
- Fixed odds: Simple `amount Ã— odds` payout
- CPMM: Calculate shares received based on reserves, apply slippage

**Impact**:
- `place_bet()` function needs complete rewrite
- Different return values (fixed odds returns bet, CPMM returns shares)
- Different validation logic

**Mitigation Strategy**:
```leo
// Split into separate functions
transition place_bet_fixed_odds(...) -> Bet { ... }
transition place_bet_cpmm(...) -> Shares { ... }

// Or use market_type to route
transition place_bet(...) -> Bet {
    let market = markets.get(market_id);
    if market.market_type == 0u8 {
        // Fixed odds logic
    } else {
        // CPMM logic
    }
}
```

**Debt Level**: ðŸ”´ **HIGH** - Core logic rewrite required

#### 3. **Payout Calculation**

**Problem**: 
- Fixed odds: `payout = bet_amount Ã— odds` (known at bet time)
- CPMM: `payout = shares Ã— 1.0` (shares value changes over time)

**Impact**:
- Resolution logic completely different
- Cannot use same `resolve_market()` function
- Historical bet tracking needs different structure

**Debt Level**: ðŸ”´ **HIGH** - Resolution system redesign

### ðŸŸ¡ Medium Technical Debt Areas

#### 4. **Database Schema**

**Problem**: Need to add CPMM-specific fields while maintaining backward compatibility.

**Impact**:
- Migration required
- Need to handle both market types
- Historical data preservation

**Mitigation Strategy**:
```sql
-- Add nullable CPMM fields (backward compatible)
ALTER TABLE markets 
ADD COLUMN market_type TEXT DEFAULT 'fixed_odds' CHECK (market_type IN ('fixed_odds', 'cpmm')),
ADD COLUMN yes_reserves NUMERIC(20,0),
ADD COLUMN no_reserves NUMERIC(20,0),
ADD COLUMN total_liquidity NUMERIC(20,0);

-- Create historical reserves table for CPMM
CREATE TABLE market_reserve_history (
    market_id UUID REFERENCES markets(id),
    timestamp TIMESTAMPTZ NOT NULL,
    yes_reserves NUMERIC(20,0) NOT NULL,
    no_reserves NUMERIC(20,0) NOT NULL,
    PRIMARY KEY (market_id, timestamp)
);
```

**Debt Level**: ðŸŸ¡ **MEDIUM** - Manageable with migrations

#### 5. **Frontend Components**

**Problem**: UI components assume fixed odds structure.

**Impact**:
- `BetForm.tsx` needs conditional rendering
- `MarketCard.tsx` needs different display logic
- Payout calculations need abstraction

**Mitigation Strategy**:
```typescript
// Abstract odds calculation
interface OddsProvider {
  getYesOdds(market: Market): number;
  getNoOdds(market: Market): number;
  calculatePayout(amount: number, side: boolean): number;
}

class FixedOddsProvider implements OddsProvider { ... }
class CPMMOddsProvider implements OddsProvider { ... }

// Use in components
const oddsProvider = market.market_type === 'fixed_odds' 
  ? new FixedOddsProvider() 
  : new CPMMOddsProvider();
```

**Debt Level**: ðŸŸ¡ **MEDIUM** - Refactoring required but manageable

### ðŸŸ¢ Low Technical Debt Areas

#### 6. **Market Creation Flow**

**Impact**: Different initialization:
- Fixed odds: Admin sets odds
- CPMM: Admin/LPs provide initial liquidity

**Debt Level**: ðŸŸ¢ **LOW** - Just different forms/UI

#### 7. **Market Display**

**Impact**: Different visualization:
- Fixed odds: Show static odds
- CPMM: Show dynamic probability, liquidity depth

**Debt Level**: ðŸŸ¢ **LOW** - UI changes only

---

## Transition Strategy: Minimizing Technical Debt

### Phase 1: Design for Extensibility (MVP)

**Action Items:**

1. **Add Market Type Field Early**
   ```sql
   -- Add to Supabase schema now (even if unused)
   ALTER TABLE markets 
   ADD COLUMN market_type TEXT DEFAULT 'fixed_odds';
   ```

2. **Abstract Odds Calculation**
   ```typescript
   // Create odds calculation utilities
   export function calculatePayout(
     market: Market, 
     amount: number, 
     side: boolean
   ): number {
     if (market.market_type === 'fixed_odds') {
       return amount * (side ? market.yes_odds : market.no_odds);
     }
     // Future: CPMM calculation
     throw new Error('CPMM not implemented yet');
   }
   ```

3. **Keep `total_yes_bets` and `total_no_bets`**
   - These are useful for both models
   - For fixed odds: Track bet volume
   - For CPMM: Can be used alongside reserves for analytics

4. **Design Contract with Extension in Mind**
   ```leo
   // Use optional fields or union-like struct
   struct Market {
       // Common fields
       id: u64,
       creator: address,
       status: u8,
       total_yes_bets: u64,
       total_no_bets: u64,
       
       // Market type indicator
       market_type: u8,  // 0 = fixed_odds, 1 = cpmm
       
       // Fixed odds (if market_type == 0)
       yes_odds: u64,
       no_odds: u64,
       
       // CPMM (if market_type == 1) - can be 0 for fixed odds
       yes_reserves: u64,
       no_reserves: u64,
   }
   ```

### Phase 2: Add CPMM Support (Future)

**Migration Path:**

1. **Deploy New Contract Version**
   - Add CPMM fields to Market struct
   - Add `create_market_cpmm()` function
   - Add `place_bet_cpmm()` function
   - Keep old functions for backward compatibility

2. **Database Migration**
   ```sql
   -- Add CPMM fields
   ALTER TABLE markets ADD COLUMN yes_reserves NUMERIC(20,0);
   ALTER TABLE markets ADD COLUMN no_reserves NUMERIC(20,0);
   
   -- Create reserve history table
   CREATE TABLE market_reserve_history (...);
   ```

3. **Frontend Updates**
   - Add market type selector in creation form
   - Update components to handle both types
   - Add CPMM-specific UI (liquidity depth, slippage warnings)

4. **Data Migration**
   - Existing fixed-odds markets remain unchanged
   - New markets can choose fixed-odds or CPMM
   - Gradual migration as markets resolve

---

## Compatibility Assessment

### âœ… What Works Well Together

1. **Bet Tracking**: `total_yes_bets` and `total_no_bets` are useful for both models
2. **Market Metadata**: Title, description, resolution rules are identical
3. **Status System**: Open/Closed/Resolved/Cancelled works for both
4. **User Interface**: Can conditionally render based on market type

### âŒ What Doesn't Work Together

1. **Odds Display**: Fixed odds vs. dynamic probability (need different UI)
2. **Payout Calculation**: Completely different formulas
3. **Bet Placement**: Different validation and execution logic
4. **Market Creation**: Different initialization requirements

---

## Recommended Approach

### Option A: Dual-Mode Architecture (Recommended)

**Strategy**: Support both fixed odds and CPMM simultaneously.

**Pros:**
- Users can choose their preferred model
- Gradual migration path
- No forced migration of existing markets
- A/B testing capability

**Cons:**
- More complex codebase
- Need to maintain both systems
- UI complexity increases

**Implementation:**
- Add `market_type` field to all layers
- Abstract odds calculation logic
- Conditional UI rendering
- Separate smart contract functions (or routing)

**Technical Debt**: ðŸŸ¡ **MEDIUM** - Manageable with good architecture

### Option B: Hard Migration

**Strategy**: Migrate all markets to CPMM, deprecate fixed odds.

**Pros:**
- Simpler long-term codebase
- Single system to maintain
- Consistent user experience

**Cons:**
- Breaking change for existing markets
- Users lose fixed-odds option
- Requires migration of all active markets
- Higher risk

**Technical Debt**: ðŸ”´ **HIGH** - Significant migration effort

### Option C: New Markets Only

**Strategy**: Keep fixed odds for existing markets, CPMM for new markets only.

**Pros:**
- No migration required
- Backward compatible
- Lower risk

**Cons:**
- Two systems forever
- Confusing for users (why different markets work differently?)
- Maintenance burden

**Technical Debt**: ðŸŸ¡ **MEDIUM** - But permanent

---

## Final Recommendation

### Updated Recommendation: Two Valid Paths

Given the AMM feasibility analysis, you have **two valid paths**:

---

### Path 1: Start with CPMM/AMM (Recommended if you want crypto-native)

**Strategy**: Implement CPMM from the beginning using Aleo's hybrid privacy model.

**Pros:**
- âœ… Crypto-native from day one
- âœ… No transition technical debt
- âœ… Leverages Aleo's unique hybrid privacy (public pools, private bets)
- âœ… Competitive advantage: More private than Polymarket, more functional than fully private
- âœ… Dynamic pricing reflects market sentiment
- âœ… Better liquidity dynamics

**Cons:**
- âŒ More complex than fixed odds
- âŒ Requires liquidity providers (or admin provides initial liquidity)
- âŒ More complex UX (slippage warnings, dynamic pricing)
- âŒ Longer development time

**Architecture:**
```leo
struct Market {
    id: u64,
    creator: address,
    market_type: u8,  // Always 1 = cpmm
    yes_reserves: u64,  // PUBLIC - enables AMM
    no_reserves: u64,   // PUBLIC - enables AMM
    status: u8,
}

transition place_bet(
    public market_id: u64,
    private amount: u64,  // PRIVATE - user privacy
    private side: bool     // PRIVATE - user privacy
) -> Shares {
    // CPMM logic with public pool updates
}
```

**Privacy Model:**
- **Public**: Pool reserves (required for AMM pricing)
- **Private**: Individual bets (amount, side, user identity)

**Technical Debt**: ðŸŸ¢ **LOW** - Single system, no migration needed

---

### Path 2: Start with Fixed Odds, Transition to CPMM Later

**Strategy**: Implement fixed odds first, add CPMM later with dual-mode support.

**Pros:**
- âœ… Simpler MVP (faster to market)
- âœ… Easier to understand for users
- âœ… Learn from users before committing to CPMM
- âœ… Lower initial complexity

**Cons:**
- âŒ Technical debt when adding CPMM
- âŒ Need to support both systems
- âŒ Migration complexity
- âŒ Not crypto-native initially

**Architecture:**
- Phase 1: Fixed odds only
- Phase 2: Add CPMM as optional market type
- Phase 3: Dual-mode support (both coexist)

**Technical Debt**: ðŸŸ¡ **MEDIUM** - Manageable with planning

---

### Recommendation Decision Matrix

**Choose Path 1 (CPMM from start) if:**
- âœ… You want crypto-native data from day one
- âœ… You're comfortable with AMM complexity
- âœ… You want to leverage Aleo's hybrid privacy model as a competitive advantage
- âœ… You have time for more complex development
- âœ… You can provide initial liquidity (or have LPs)

**Choose Path 2 (Fixed odds first) if:**
- âœ… You want fastest MVP to market
- âœ… You prefer simpler UX initially
- âœ… You want to validate the concept before committing to CPMM
- âœ… You're unsure about AMM complexity
- âœ… You want to learn from users first

---

### Key Insight: Hybrid Privacy Model Works for Both

**Regardless of which path you choose**, the hybrid privacy model (public pools, private bets) is your competitive advantage:

- **More private than Polymarket**: Individual bets are hidden
- **More functional than fully private**: AMM works with public pools
- **Unique positioning**: Only possible on Aleo

---

### Technical Debt Estimate

**Path 1 (CPMM from start):**
- Technical Debt: ðŸŸ¢ **LOW** - Single system, no migration

**Path 2 (Fixed odds â†’ CPMM):**
- Without planning: ðŸ”´ **HIGH** (significant refactoring)
- With planning: ðŸŸ¡ **MEDIUM** (manageable refactoring)

---

### Final Recommendation

**Given your question about starting with AMM:**

**âœ… YES, start with CPMM/AMM from the beginning** if:
1. You want crypto-native data
2. You're comfortable with the complexity
3. You want to leverage Aleo's hybrid privacy model as a competitive advantage
4. You can handle liquidity provision (admin or LPs)

**The hybrid privacy model (public pools, private bets) makes this feasible and competitive.**

**If you prefer simplicity and speed:**
- Start with fixed odds
- Plan for CPMM transition (add extensibility hooks)
- Use hybrid privacy model when adding CPMM

**Both paths are valid. Choose based on your priorities: crypto-native complexity vs. MVP simplicity.**

---

## Conclusion

**AMM/CPMM is fully feasible on Aleo** using a hybrid privacy architecture:

1. **Public pool reserves** â†’ Enables AMM functionality
2. **Private individual bets** â†’ Maintains user privacy
3. **Competitive advantage** â†’ More private than Polymarket, more functional than fully private

**You can start with CPMM from the beginning** (Path 1) or transition from fixed odds (Path 2). Both are valid approaches, with different trade-offs in complexity vs. speed.

**The key insight**: Aleo's support for both public and private state enables a unique hybrid model that's not possible on fully public blockchains (like Ethereum/Polygon where Polymarket runs) or fully private systems (where AMM wouldn't work).
</file>

<file path="business/research.md">
# Obsidian Market - Research & Market Validation

## Executive Summary

**Obsidian Market** is a prediction market platform built on the Aleo blockchain, offering privacy-preserving binary prediction markets with cross-platform support (iOS, Android, and Web). The platform enables users to create and participate in Yes/No prediction markets with fixed-odds betting, leveraging Aleo's zero-knowledge cryptography for transaction privacy.

## Purpose of the Application

### Core Mission
Obsidian Market democratizes access to prediction markets by providing a lightweight, privacy-focused platform that enables users to bet on future events across various topics. Unlike traditional prediction markets that operate on public blockchains, Obsidian Market leverages Aleo's privacy-preserving technology to protect user betting patterns and financial information.

### Key Value Propositions

1. **Privacy-Preserving Prediction Markets**
   - All transactions and bets are executed on Aleo blockchain with zero-knowledge proofs
   - User betting patterns, positions, and financial data remain private
   - Addresses a critical gap in existing prediction markets where all trades are publicly visible

3. **Decentralized & Trustless**
   - Smart contract-based escrow system ensures funds are secure
   - No central authority controls user funds
   - Transparent resolution process with admin-controlled market creation

### Target Use Cases

- **Political Events**: Betting on election outcomes, policy decisions, political events
- **Sports**: Game outcomes, championship winners, player performance
- **Technology**: Product launches, company milestones, tech industry events
- **Entertainment**: Award shows, box office performance, celebrity events
- **Finance**: Market movements, economic indicators, corporate events
- **General Knowledge**: Any future event with a clear Yes/No outcome

## Competitive Advantages

### 1. Privacy-First Architecture

**Differentiator**: Obsidian Market is built on Aleo, a privacy-preserving blockchain that uses zero-knowledge proofs to hide transaction details.

**Competitive Context**:
- **Polymarket** (largest prediction market): All trades are publicly visible on-chain, exposing user positions and betting strategies
- **Traditional prediction markets**: Require KYC/AML, exposing user identity and betting history
- **Obsidian Market**: Complete transaction privacy while maintaining verifiable on-chain settlement

**Market Opportunity**: 
- Privacy-conscious traders who don't want to expose their positions
- Institutional users who need to protect trading strategies
- Users in jurisdictions with restrictive gambling regulations

### 3. Emerging Blockchain Ecosystem

**Differentiator**: Built on Aleo, an emerging privacy-focused blockchain with growing developer and user adoption.

**Competitive Context**:
- **Polymarket**: Built on Polygon/Ethereum (mature but public)
- **Other prediction markets**: Mostly on Ethereum L2s or alternative chains
- **Obsidian Market**: Early mover in Aleo ecosystem, potential for first-mover advantage

**Market Opportunity**:
- Early adopters of Aleo blockchain technology
- Users seeking alternatives to Ethereum-based platforms
- Alignment with Aleo's growing ecosystem and developer community

### 5. Lightweight MVP Approach

**Differentiator**: Focused on core functionality with rapid iteration and time-to-market.

**Competitive Context**:
- **Polymarket**: Complex platform with many features, slower to adapt
- **Enterprise solutions**: Over-engineered, slow development cycles
- **Obsidian Market**: Lean MVP allows quick pivots and feature additions based on user feedback

**Market Opportunity**:
- Faster response to market demands
- Lower development and operational costs
- Ability to test and validate features quickly

### 6. Hybrid Architecture (On-Chain + Off-Chain)

**Differentiator**: Smart contracts handle financial transactions (bets, escrow, payouts) while Supabase handles metadata (descriptions, UI state, market info).

**Competitive Context**:
- **Fully on-chain**: Expensive, slow, limited metadata
- **Fully off-chain**: Centralized, trust required
- **Obsidian Market**: Best of both worlds - trustless financial layer with efficient metadata storage

**Market Opportunity**:
- Lower transaction costs for non-financial data
- Faster UI updates and real-time market information
- Scalable architecture that can handle high transaction volumes

## Market Validation Questions

### For AI Evaluation:

1. **Market Demand**: Is there sufficient demand for privacy-preserving prediction markets? Are users willing to trade on a newer blockchain (Aleo) vs. established platforms?

2. **Competitive Moat**: Are the competitive advantages (privacy, simplicity, cross-platform) strong enough to differentiate from Polymarket and other established players?

3. **Investor Interest**: Would investors be interested in a prediction market platform built on Aleo? Is the privacy-preserving angle compelling enough for funding?

4. **User Adoption**: Will users migrate from established platforms (Polymarket) to a new platform? What is the switching cost and friction?

5. **Regulatory Risk**: How do privacy-preserving features affect regulatory compliance? Are there jurisdictions where this is an advantage or disadvantage?

6. **Technical Feasibility**: Is Aleo blockchain mature enough to support a production prediction market? Are there scalability or performance concerns?

7. **Business Model**: What is the revenue model? Transaction fees? Market creation fees? How does this compare to competitors?

8. **Go-to-Market Strategy**: How will Obsidian Market acquire users? What is the marketing strategy to compete with established platforms? Polymarket current has a 2.6/5 stars in the Android app store. The app experience is not stable for many users

9. **Network Effects**: Prediction markets benefit from network effects (more users = better liquidity = more accurate odds). Can Obsidian Market overcome the cold start problem?

10. **Long-term Viability**: Is this a sustainable business or a feature that could be added to existing platforms? What prevents Polymarket from adding privacy features?

## Key Metrics for Success

- **User Growth**: Number of active users and wallets connected
- **Market Activity**: Number of markets created, bets placed, total volume
- **Liquidity**: Average market size and bet frequency
- **Retention**: User return rate and engagement metrics
- **Revenue**: Transaction fees and platform revenue
- **Network Growth**: Growth of Aleo ecosystem and developer adoption

## Conclusion

Obsidian Market aims to capture market share in the prediction market space by offering privacy-preserving transactions, simplified user experience, and cross-platform accessibility. The platform leverages Aleo's emerging blockchain technology to differentiate from established players like Polymarket, while maintaining focus on core functionality through a lightweight MVP approach.

The success of Obsidian Market depends on:
1. User willingness to adopt Aleo blockchain
2. Strength of privacy-preserving value proposition
3. Ability to overcome network effects of established platforms
4. Execution of go-to-market strategy
5. Maturity and scalability of Aleo blockchain infrastructure

---

**Request for Evaluation**: Please evaluate this project's viability, market potential, and investor appeal. Consider the competitive advantages, market dynamics, technical feasibility, and business model. Provide insights on whether this project is valid, if the market will have interest, and if investors can be found.
</file>

<file path="docs/aleo-local-dev.md">
# Aleo Local Development Guide

## Prerequisites

- Leo CLI installed (v3.3.1 or compatible)
- SnarkVM for local execution
- Basic understanding of Aleo/Leo programming

## Setup

### 1. Install Leo CLI

If not already installed:

```bash
# Install via package manager or download from https://leo-lang.org
# Check installation
leo --version
```

### 2. Build the Program

Navigate to the `leo/` directory and build:

```bash
cd leo
leo build
```

This compiles the Leo program and generates:
- `build/main.aleo` - Compiled program
- `build/program.json` - Program metadata

### 3. Run Tests

Test the smart contract functions:

```bash
leo test
```

This runs all tests in `leo/tests/test_leo.leo` and verifies:
- Market creation works
- Bet placement works
- Minimum bet validation
- Market state updates

## Local Development Workflow

### 1. Make Changes

Edit `leo/src/main.leo` to modify the contract.

### 2. Build and Test

```bash
leo build
leo test
```

### 3. Deploy Locally (SnarkVM)

For local testing with SnarkVM:

```bash
# Start local SnarkVM node (if available)
# Deploy contract
leo deploy
```

**Note:** Local SnarkVM setup may vary. Check Aleo documentation for current local development tools.

## Testing Transactions

### Create a Market

```bash
# Example: Create market with ID 1, 2.0x odds for both sides
leo run create_market 1u64 200u64 200u64
```

### Place a Bet

```bash
# Example: Place 1 ALEO bet on Yes side for market 1
leo run place_bet 1u64 true 1000000u64
```

### Query Market State

```bash
# Get market information
leo run get_market 1u64
```

## Program Structure

### Data Structures

- **Market**: Stores market configuration and bet totals
- **Bet**: Stores individual bet information

### Mappings

- `markets`: Maps market_id â†’ Market record
- `bets`: Maps bet_id â†’ Bet record
- `market_counter`: Tracks market IDs (for future use)

### Transitions

- `create_market`: Admin creates new market
- `place_bet`: User places bet on market
- `get_market`: Query market state
- `get_bet`: Query bet information

## Constants

- `MIN_BET_AMOUNT`: 1,000,000 microcredits (1 ALEO)
- Market statuses: 0=Open, 1=Closed, 2=Resolved, 3=Cancelled

## Troubleshooting

### Build Errors

- Check Leo version: `leo --version` (should be 3.3.1)
- Verify syntax matches Leo language spec
- Check for typos in record/mapping names

### Test Failures

- Review test assertions
- Check that market exists before placing bets
- Verify minimum bet amounts

### Deployment Issues

- Ensure SnarkVM is running (if using local node)
- Check network configuration
- Verify admin address is correct

## Next Steps

1. Test all transitions locally
2. Deploy to Aleo testnet (see deployment guide)
3. Integrate with frontend

## Resources

- [Leo Language Documentation](https://developer.aleo.org/leo/)
- [Aleo Documentation](https://developer.aleo.org/)
- [SnarkVM Guide](https://developer.aleo.org/snarkvm/)
</file>

<file path="docs/database-upgrades.md">
# Database Upgrades for Advanced Filtering and Search

## Overview

This document outlines the database schema changes and implementation plan needed to support Polymarket-style advanced filtering, searching, and categorization capabilities.

## Features to Implement

Based on Polymarket's interface, we need to support:

1. **Categories** - Hierarchical category system (Politics, Sports, Finance, Crypto, Geopolitics, etc.)
2. **Tags** - Flexible tagging system for topics, people, events (Trump, Epstein, Fed, Token Sales, etc.)
3. **Full-Text Search** - Search across titles, descriptions, tags, and categories
4. **Advanced Sorting** - Trending, Liquidity, Volume, Newest, Ending Soon, Competitive
5. **Status Filtering** - Active, Resolved, All
6. **Category Hiding** - User preferences to hide specific categories
7. **Volume & Liquidity Tracking** - Real-time or cached trading metrics
8. **Frequency Filtering** - Market update frequency or activity level

---

## Database Schema Changes

### 1. Categories Table

Create a hierarchical category system with parent-child relationships.

```sql
-- Categories table for organizing markets
CREATE TABLE categories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL UNIQUE, -- e.g., "Politics", "Sports", "Finance"
    slug TEXT NOT NULL UNIQUE, -- URL-friendly version: "politics", "sports"
    parent_id UUID REFERENCES categories(id) ON DELETE SET NULL, -- For subcategories
    description TEXT,
    icon TEXT, -- Icon identifier or emoji
    display_order INTEGER DEFAULT 0, -- For custom ordering in UI
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes for categories
CREATE INDEX idx_categories_parent_id ON categories(parent_id);
CREATE INDEX idx_categories_slug ON categories(slug);
CREATE INDEX idx_categories_active ON categories(is_active) WHERE is_active = true;

-- Example categories:
-- Politics (parent)
--   â””â”€ Trump (subcategory)
--   â””â”€ Elections (subcategory)
-- Sports (parent)
-- Finance (parent)
--   â””â”€ Fed (subcategory)
-- Crypto (parent)
--   â””â”€ Token Sales (subcategory)
```

### 2. Tags Table

Flexible tagging system for topics, people, events, and keywords.

```sql
-- Tags table for flexible market tagging
CREATE TABLE tags (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL UNIQUE, -- e.g., "Trump", "Epstein", "Fed", "Ukraine"
    slug TEXT NOT NULL UNIQUE, -- URL-friendly: "trump", "epstein"
    description TEXT,
    tag_type TEXT DEFAULT 'topic', -- 'topic', 'person', 'event', 'location', 'organization'
    usage_count INTEGER DEFAULT 0, -- Track how many markets use this tag
    is_trending BOOLEAN DEFAULT false, -- For highlighting trending tags
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes for tags
CREATE INDEX idx_tags_slug ON tags(slug);
CREATE INDEX idx_tags_type ON tags(tag_type);
CREATE INDEX idx_tags_trending ON tags(is_trending) WHERE is_trending = true;
CREATE INDEX idx_tags_usage_count ON tags(usage_count DESC); -- For popular tags

-- Full-text search index for tags
CREATE INDEX idx_tags_name_trgm ON tags USING gin(name gin_trgm_ops);
```

### 3. Market Categories Junction Table

Many-to-many relationship between markets and categories.

```sql
-- Junction table for market categories
CREATE TABLE market_categories (
    market_id UUID NOT NULL REFERENCES markets(id) ON DELETE CASCADE,
    category_id UUID NOT NULL REFERENCES categories(id) ON DELETE CASCADE,
    is_primary BOOLEAN DEFAULT false, -- One primary category per market
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    PRIMARY KEY (market_id, category_id)
);

-- Indexes
CREATE INDEX idx_market_categories_market_id ON market_categories(market_id);
CREATE INDEX idx_market_categories_category_id ON market_categories(category_id);
CREATE INDEX idx_market_categories_primary ON market_categories(category_id) WHERE is_primary = true;

-- Constraint: Only one primary category per market
CREATE UNIQUE INDEX idx_market_categories_one_primary 
    ON market_categories(market_id) 
    WHERE is_primary = true;
```

### 4. Market Tags Junction Table

Many-to-many relationship between markets and tags.

```sql
-- Junction table for market tags
CREATE TABLE market_tags (
    market_id UUID NOT NULL REFERENCES markets(id) ON DELETE CASCADE,
    tag_id UUID NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    PRIMARY KEY (market_id, tag_id)
);

-- Indexes
CREATE INDEX idx_market_tags_market_id ON market_tags(market_id);
CREATE INDEX idx_market_tags_tag_id ON market_tags(tag_id);
```

### 5. Market Metrics Table

Track volume, liquidity, and other trading metrics. These can be updated from blockchain queries or cached.

```sql
-- Market metrics for sorting and filtering
CREATE TABLE market_metrics (
    market_id UUID PRIMARY KEY REFERENCES markets(id) ON DELETE CASCADE,
    
    -- Volume metrics (in microcredits, converted to ALEO)
    volume_24h NUMERIC(20,0) DEFAULT 0, -- 24-hour trading volume
    volume_7d NUMERIC(20,0) DEFAULT 0, -- 7-day trading volume
    volume_30d NUMERIC(20,0) DEFAULT 0, -- 30-day trading volume
    volume_all_time NUMERIC(20,0) DEFAULT 0, -- Total volume
    
    -- Liquidity metrics
    liquidity NUMERIC(20,0) DEFAULT 0, -- Current liquidity pool size
    
    -- Activity metrics
    bet_count_24h INTEGER DEFAULT 0, -- Number of bets in last 24h
    bet_count_total INTEGER DEFAULT 0, -- Total number of bets
    
    -- Trending score (calculated field)
    trending_score NUMERIC(10,4) DEFAULT 0, -- Calculated score for trending
    
    -- Competitive score (how close the odds are)
    competitive_score NUMERIC(10,4) DEFAULT 0, -- Closer to 50/50 = more competitive
    
    -- Timestamps
    last_updated TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes for sorting
CREATE INDEX idx_market_metrics_volume_24h ON market_metrics(volume_24h DESC);
CREATE INDEX idx_market_metrics_liquidity ON market_metrics(liquidity DESC);
CREATE INDEX idx_market_metrics_trending_score ON market_metrics(trending_score DESC);
CREATE INDEX idx_market_metrics_competitive_score ON market_metrics(competitive_score DESC);
CREATE INDEX idx_market_metrics_bet_count_24h ON market_metrics(bet_count_24h DESC);
```

### 6. User Preferences Table

Store user preferences for hiding categories and other UI customizations.

```sql
-- User preferences for filtering
CREATE TABLE user_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_address TEXT NOT NULL, -- Wallet address (or user ID if auth is added)
    
    -- Hidden categories
    hidden_category_ids UUID[] DEFAULT '{}', -- Array of category IDs to hide
    
    -- Hidden tags
    hidden_tag_ids UUID[] DEFAULT '{}', -- Array of tag IDs to hide
    
    -- Default filters
    default_status_filter TEXT DEFAULT 'active', -- 'active', 'resolved', 'all'
    default_sort_by TEXT DEFAULT 'trending', -- 'trending', 'liquidity', 'volume', etc.
    
    -- Other preferences
    hide_sports BOOLEAN DEFAULT false,
    hide_crypto BOOLEAN DEFAULT false,
    hide_earnings BOOLEAN DEFAULT false,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    
    UNIQUE(user_address)
);

-- Indexes
CREATE INDEX idx_user_preferences_user_address ON user_preferences(user_address);
```

### 7. Market Search Index

Full-text search capabilities using PostgreSQL's built-in search.

```sql
-- Add search vector column to markets table
ALTER TABLE markets ADD COLUMN search_vector tsvector;

-- Create function to update search vector
CREATE OR REPLACE FUNCTION markets_search_vector_update() RETURNS TRIGGER AS $$
BEGIN
    NEW.search_vector := 
        setweight(to_tsvector('english', COALESCE(NEW.title, '')), 'A') ||
        setweight(to_tsvector('english', COALESCE(NEW.description, '')), 'B') ||
        setweight(to_tsvector('english', COALESCE(NEW.resolution_rules, '')), 'C');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to auto-update search vector
CREATE TRIGGER markets_search_vector_trigger
    BEFORE INSERT OR UPDATE ON markets
    FOR EACH ROW
    EXECUTE FUNCTION markets_search_vector_update();

-- Create GIN index for fast full-text search
CREATE INDEX idx_markets_search_vector ON markets USING gin(search_vector);

-- Update existing rows
UPDATE markets SET search_vector = 
    setweight(to_tsvector('english', COALESCE(title, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(description, '')), 'B') ||
    setweight(to_tsvector('english', COALESCE(resolution_rules, '')), 'C');
```

### 8. Enable Required Extensions

```sql
-- Enable pg_trgm for fuzzy text search
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Enable unaccent for accent-insensitive search (optional)
CREATE EXTENSION IF NOT EXISTS unaccent;
```

---

## Implementation Plan

### Phase 1: Core Schema (Week 1)

1. **Create migration file** for all new tables
2. **Add categories** - Seed initial categories (Politics, Sports, Finance, Crypto, etc.)
3. **Add tags table** - Create tags system
4. **Add junction tables** - Market-categories and market-tags relationships
5. **Update markets table** - Add search_vector column and triggers
6. **Test basic queries** - Verify relationships work correctly

### Phase 2: Metrics & Search (Week 2)

1. **Create market_metrics table** - Set up metrics tracking
2. **Implement metrics update job** - Background job to update metrics from blockchain
3. **Add full-text search** - Implement search_vector triggers and indexes
4. **Create search functions** - Helper functions for complex search queries
5. **Test search performance** - Ensure queries are fast with indexes

### Phase 3: User Preferences (Week 3)

1. **Create user_preferences table** - Store user filter preferences
2. **Implement preference API** - CRUD operations for preferences
3. **Add preference hooks** - React hooks to manage preferences
4. **Test preference persistence** - Verify preferences save and load correctly

### Phase 4: Frontend Integration (Week 4)

1. **Category filtering UI** - Build category navigation component
2. **Tag filtering UI** - Build tag selection/filtering component
3. **Search bar** - Implement full-text search input
4. **Sort dropdowns** - Build sorting UI (Trending, Volume, etc.)
5. **Filter sidebar** - Build comprehensive filter panel
6. **Results display** - Update market list to show filtered results

---

## Query Examples

### 1. Search Markets by Text

```sql
-- Full-text search across title, description, and resolution rules
SELECT m.*, 
       ts_rank(m.search_vector, query) AS rank
FROM markets m,
     to_tsquery('english', 'trump & election') query
WHERE m.search_vector @@ query
  AND m.status = 'open'
ORDER BY rank DESC, m.created_at DESC
LIMIT 20;
```

### 2. Filter by Category

```sql
-- Get markets in Politics category (including subcategories)
WITH RECURSIVE category_tree AS (
    SELECT id FROM categories WHERE slug = 'politics'
    UNION ALL
    SELECT c.id FROM categories c
    INNER JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT DISTINCT m.*
FROM markets m
INNER JOIN market_categories mc ON m.id = mc.market_id
WHERE mc.category_id IN (SELECT id FROM category_tree)
  AND m.status = 'active'
ORDER BY m.created_at DESC;
```

### 3. Filter by Tags

```sql
-- Get markets tagged with "Trump" or "Epstein"
SELECT DISTINCT m.*
FROM markets m
INNER JOIN market_tags mt ON m.id = mt.market_id
INNER JOIN tags t ON mt.tag_id = t.id
WHERE t.slug IN ('trump', 'epstein')
  AND m.status = 'active'
ORDER BY m.created_at DESC;
```

### 4. Sort by Trending

```sql
-- Sort by trending score (combines volume, recency, activity)
SELECT m.*, mm.trending_score
FROM markets m
LEFT JOIN market_metrics mm ON m.id = mm.market_id
WHERE m.status = 'active'
ORDER BY 
    COALESCE(mm.trending_score, 0) DESC,
    mm.volume_24h DESC NULLS LAST,
    m.created_at DESC
LIMIT 50;
```

### 5. Sort by Volume

```sql
-- Sort by 24-hour volume
SELECT m.*, mm.volume_24h
FROM markets m
LEFT JOIN market_metrics mm ON m.id = mm.market_id
WHERE m.status = 'active'
ORDER BY mm.volume_24h DESC NULLS LAST
LIMIT 50;
```

### 6. Sort by Ending Soon

```sql
-- Sort by resolution deadline (ending soonest first)
SELECT m.*
FROM markets m
WHERE m.status = 'active'
  AND m.resolution_deadline > now()
ORDER BY m.resolution_deadline ASC
LIMIT 50;
```

### 7. Complex Filter: Category + Tags + Search

```sql
-- Search for "election" in Politics category, tagged with "Trump"
SELECT DISTINCT m.*,
       ts_rank(m.search_vector, query) AS rank
FROM markets m,
     to_tsquery('english', 'election') query
INNER JOIN market_categories mc ON m.id = mc.market_id
INNER JOIN categories c ON mc.category_id = c.id
INNER JOIN market_tags mt ON m.id = mt.market_id
INNER JOIN tags t ON mt.tag_id = t.id
WHERE m.search_vector @@ query
  AND c.slug = 'politics'
  AND t.slug = 'trump'
  AND m.status = 'active'
ORDER BY rank DESC, m.created_at DESC;
```

### 8. Apply User Preferences (Hide Categories)

```sql
-- Get markets excluding user's hidden categories
SELECT DISTINCT m.*
FROM markets m
LEFT JOIN market_categories mc ON m.id = mc.market_id
LEFT JOIN user_preferences up ON up.user_address = $1
WHERE m.status = 'active'
  AND (mc.category_id IS NULL OR mc.category_id != ALL(up.hidden_category_ids))
ORDER BY m.created_at DESC;
```

---

## Metrics Calculation

### Trending Score Formula

```sql
-- Update trending score (combines multiple factors)
UPDATE market_metrics
SET trending_score = (
    -- Volume weight (40%)
    (LOG(COALESCE(volume_24h, 0) + 1) / LOG(1000000)) * 0.4 +
    -- Recent activity weight (30%)
    (LOG(COALESCE(bet_count_24h, 0) + 1) / LOG(100)) * 0.3 +
    -- Recency weight (20%) - newer markets get boost
    (EXTRACT(EPOCH FROM (now() - (SELECT created_at FROM markets WHERE id = market_id))) / 86400) * 0.2 +
    -- Competitive weight (10%) - close odds = more interesting
    competitive_score * 0.1
)
WHERE last_updated < now() - INTERVAL '1 hour';
```

### Competitive Score Formula

```sql
-- Calculate competitive score (closer to 50/50 = more competitive)
UPDATE market_metrics mm
SET competitive_score = 1 - ABS(
    (SELECT yes_odds FROM markets WHERE id = mm.market_id) - 
    (SELECT no_odds FROM markets WHERE id = mm.market_id)
) / GREATEST(
    (SELECT yes_odds + no_odds FROM markets WHERE id = mm.market_id),
    1
)
FROM markets m
WHERE mm.market_id = m.id;
```

---

## API/Query Functions

### Recommended Supabase Functions

Create PostgreSQL functions for common queries:

```sql
-- Function: Search markets with filters
CREATE OR REPLACE FUNCTION search_markets(
    search_query TEXT DEFAULT NULL,
    category_slug TEXT DEFAULT NULL,
    tag_slugs TEXT[] DEFAULT NULL,
    status_filter TEXT DEFAULT 'active',
    sort_by TEXT DEFAULT 'trending',
    limit_count INTEGER DEFAULT 50,
    offset_count INTEGER DEFAULT 0,
    user_address TEXT DEFAULT NULL
)
RETURNS TABLE (
    market_id UUID,
    title TEXT,
    description TEXT,
    status TEXT,
    volume_24h NUMERIC,
    liquidity NUMERIC,
    trending_score NUMERIC,
    created_at TIMESTAMPTZ,
    rank REAL
) AS $$
BEGIN
    -- Implementation combines all filters and sorting logic
    -- Returns paginated results
END;
$$ LANGUAGE plpgsql;
```

---

## Migration Strategy

### Step-by-Step Migration

1. **Create new tables** (categories, tags, junction tables, metrics, preferences)
2. **Add search_vector column** to markets table
3. **Create indexes** for performance
4. **Seed initial data** (categories, popular tags)
5. **Migrate existing markets** (assign categories/tags manually or via script)
6. **Update application code** to use new schema
7. **Set up metrics update job** (cron job or background worker)
8. **Test thoroughly** before deploying

### Rollback Plan

Keep the old query methods working alongside new ones during migration. Gradually migrate features to use new schema.

---

## Performance Considerations

### Indexing Strategy

- **GIN indexes** for full-text search (search_vector)
- **B-tree indexes** for foreign keys and common filters
- **Composite indexes** for common query patterns
- **Partial indexes** for filtered queries (e.g., active markets only)

### Caching Strategy

- **Cache popular queries** (Redis or in-memory cache)
- **Cache category/tag lists** (rarely change)
- **Cache user preferences** (per-user cache)
- **Cache trending markets** (update every 5-10 minutes)

### Query Optimization

- **Use EXPLAIN ANALYZE** to optimize slow queries
- **Limit result sets** with pagination
- **Use materialized views** for complex aggregations if needed
- **Consider read replicas** for heavy read workloads

---

## Future Enhancements

1. **Auto-tagging** - Use AI/ML to automatically tag markets based on content
2. **Category suggestions** - Suggest categories when creating markets
3. **Tag recommendations** - Suggest relevant tags based on title/description
4. **Search analytics** - Track popular searches and improve search relevance
5. **Saved searches** - Allow users to save search queries
6. **Market collections** - Curated lists of markets (like "Best of 2025")
7. **Related markets** - Show related markets based on tags/categories
8. **Search autocomplete** - Suggest search terms as user types

---

## Testing Checklist

- [ ] Categories can be created and assigned to markets
- [ ] Tags can be created and assigned to markets
- [ ] Full-text search returns relevant results
- [ ] Sorting by volume/liquidity/trending works correctly
- [ ] Filtering by category works (including subcategories)
- [ ] Filtering by tags works (including multiple tags)
- [ ] User preferences persist correctly
- [ ] Hidden categories are excluded from results
- [ ] Complex queries perform well (< 100ms)
- [ ] Metrics update correctly from blockchain data
- [ ] Search handles special characters and edge cases
- [ ] Pagination works correctly with all filters

---

## Notes

- **Blockchain Integration**: Market metrics (volume, liquidity) should ideally be queried from the Aleo blockchain. Consider caching these values and updating them periodically (every 5-15 minutes) rather than querying on every request.

- **Search Quality**: Full-text search quality depends on good content in title and description fields. Consider adding search result highlighting and relevance scoring.

- **Scalability**: As the number of markets grows, consider partitioning the markets table by date or using read replicas for search queries.

- **User Experience**: Consider adding search result counts, "Did you mean?" suggestions, and search history.
</file>

<file path="docs/orm-vs-supabase.md">
# Do You Need an ORM with Supabase?

## Short Answer

**No, you don't need an ORM.** Supabase provides a query builder and type-safe client that covers most ORM use cases. However, Supabase is **not a full ORM** - it's more like a "smart database client" with some ORM-like features.

---

## What Supabase Provides (ORM-like Features)

### âœ… **Type-Safe Queries**
Supabase generates TypeScript types from your database schema:

```typescript
import { supabase } from '@/lib/supabase';
import type { Market } from '@/types/supabase';

// Type-safe query - TypeScript knows the return type
const { data, error } = await supabase
  .from('markets')
  .select('*')
  .eq('status', 'open');
// data is typed as Market[] | null
```

### âœ… **Query Builder**
Method chaining for building queries (similar to ORM query builders):

```typescript
// Similar to Prisma/TypeORM query builders
const { data } = await supabase
  .from('markets')
  .select('*, categories(*), tags(*)') // Automatic joins
  .eq('status', 'open')
  .order('created_at', { ascending: false })
  .limit(10);
```

### âœ… **Automatic Relationships**
PostgREST (Supabase's API layer) handles joins automatically:

```typescript
// Automatically joins related tables
const { data } = await supabase
  .from('markets')
  .select(`
    *,
    market_categories(
      category:categories(*)
    ),
    market_tags(
      tag:tags(*)
    )
  `);
```

### âœ… **Real-time Subscriptions**
Built-in real-time capabilities (most ORMs don't have this):

```typescript
const channel = supabase
  .channel('markets-changes')
  .on('postgres_changes', {
    event: '*',
    schema: 'public',
    table: 'markets'
  }, (payload) => {
    // Handle real-time updates
  })
  .subscribe();
```

### âœ… **Row Level Security (RLS)**
Database-level security policies (better than ORM-level):

```sql
-- RLS policies in database
CREATE POLICY "Markets are viewable by everyone"
  ON markets FOR SELECT
  USING (true);
```

---

## What Supabase Does NOT Provide (Traditional ORM Features)

### âŒ **Model Classes/Entities**
No object-oriented model classes:

```typescript
// âŒ Can't do this (like Sequelize/TypeORM)
class Market extends Model {
  static async findByStatus(status: string) {
    return this.findAll({ where: { status } });
  }
}

// âœ… Instead, use functions/hooks
export function useMarkets(status?: MarketStatus) {
  // Hook implementation
}
```

### âŒ **Active Record Pattern**
No `market.save()`, `market.update()`, etc.:

```typescript
// âŒ Can't do this (like Rails ActiveRecord)
const market = new Market({ title: '...' });
await market.save();

// âœ… Instead, use Supabase client
await supabase.from('markets').insert({ title: '...' });
```

### âŒ **Migrations Management**
Supabase has migrations, but they're SQL-based, not ORM-based:

```typescript
// âŒ Can't do this (like Prisma migrations)
prisma migrate dev --name add_tags

// âœ… Instead, use SQL migrations
// supabase/migrations/20240101000000_add_tags.sql
```

### âŒ **Model Validation**
No built-in validation (you handle it in application code):

```typescript
// âŒ No built-in validators
class Market {
  @IsString()
  @MinLength(10)
  title: string;
}

// âœ… Instead, validate in your forms/components
```

### âŒ **Lazy Loading**
No automatic relationship loading:

```typescript
// âŒ Can't do this (like TypeORM)
const market = await marketRepo.findOne(1);
const categories = await market.categories; // Lazy load

// âœ… Instead, explicitly select relationships
const { data } = await supabase
  .from('markets')
  .select('*, categories(*)');
```

---

## Comparison: Supabase vs Popular ORMs

| Feature | Supabase | Prisma | TypeORM | Sequelize |
|---------|----------|--------|---------|-----------|
| Type Safety | âœ… Generated types | âœ… Generated types | âœ… Decorators | âš ï¸ Manual types |
| Query Builder | âœ… Method chaining | âœ… Method chaining | âœ… Query Builder | âœ… Query Builder |
| Relationships | âœ… Auto-joins | âœ… Relations | âœ… Relations | âœ… Associations |
| Migrations | âœ… SQL-based | âœ… Schema-based | âœ… TypeScript | âœ… JS/TS |
| Real-time | âœ… Built-in | âŒ No | âŒ No | âŒ No |
| RLS | âœ… Database-level | âŒ No | âŒ No | âŒ No |
| Model Classes | âŒ No | âš ï¸ Partial | âœ… Yes | âœ… Yes |
| Active Record | âŒ No | âš ï¸ Partial | âœ… Yes | âœ… Yes |
| Validation | âŒ No | âš ï¸ Zod integration | âœ… Decorators | âš ï¸ Manual |

---

## When You Might Want an ORM

### Consider an ORM if:

1. **Complex Business Logic**
   - Need model methods with business logic
   - Want to encapsulate data access in classes
   - Prefer object-oriented patterns

2. **Multiple Database Support**
   - Need to support PostgreSQL, MySQL, SQLite, etc.
   - Want database-agnostic code
   - Supabase is PostgreSQL-only

3. **Advanced Query Features**
   - Complex aggregations that are easier with ORM abstractions
   - Need query result transformations
   - Want to build complex query builders

4. **Team Preference**
   - Team is more familiar with ORMs
   - Existing codebase uses ORMs
   - Want consistency with other projects

### You DON'T need an ORM if:

1. âœ… **You're using Supabase** (which you are)
2. âœ… **Simple to moderate complexity queries** (most apps)
3. âœ… **Want real-time features** (Supabase excels here)
4. âœ… **Want database-level security** (RLS is powerful)
5. âœ… **Prefer SQL-like queries** (Supabase is SQL-like)
6. âœ… **Want less abstraction** (closer to SQL)

---

## Recommended Approach for Your Project

### Current Setup (Good!)

You're already using Supabase correctly:

```typescript
// âœ… Direct Supabase queries
const { data, error } = await supabase
  .from('markets')
  .select('*')
  .eq('status', 'open');

// âœ… Custom hooks for reusability
export function useMarkets(status?: MarketStatus) {
  // Encapsulates query logic
}
```

### Optional: Add a Light Abstraction Layer

You could create a thin abstraction layer for common patterns:

```typescript
// lib/markets.ts - Light abstraction, not a full ORM
export const markets = {
  async findAll(filters?: { status?: MarketStatus }) {
    let query = supabase.from('markets').select('*');
    
    if (filters?.status) {
      query = query.eq('status', filters.status);
    }
    
    return query.order('created_at', { ascending: false });
  },
  
  async findById(id: string) {
    return supabase
      .from('markets')
      .select('*')
      .eq('id', id)
      .single();
  },
  
  async create(market: InsertMarket) {
    return supabase.from('markets').insert(market);
  },
  
  // Add more common operations...
};
```

This gives you:
- âœ… Reusable query patterns
- âœ… Consistent error handling
- âœ… Still uses Supabase directly (no ORM overhead)
- âœ… Easy to test and maintain

---

## For Your Advanced Filtering Features

With the database upgrades you're planning (categories, tags, search), Supabase handles this well:

### âœ… **Complex Queries Work Great**

```typescript
// Search with filters - Supabase handles this well
const { data } = await supabase
  .from('markets')
  .select(`
    *,
    market_categories(
      category:categories(*)
    ),
    market_tags(
      tag:tags(*)
    ),
    market_metrics(*)
  `)
  .textSearch('search_vector', 'trump & election')
  .eq('status', 'active')
  .order('trending_score', { ascending: false });
```

### âœ… **Full-Text Search Built-in**

```typescript
// PostgreSQL full-text search via Supabase
const { data } = await supabase
  .from('markets')
  .select('*')
  .textSearch('search_vector', 'trump');
```

### âœ… **Complex Joins**

```typescript
// Multiple joins handled automatically
const { data } = await supabase
  .from('markets')
  .select(`
    *,
    market_categories!inner(
      category:categories!inner(*)
    ),
    market_tags!inner(
      tag:tags!inner(*)
    )
  `)
  .eq('market_categories.category.slug', 'politics')
  .in('market_tags.tag.slug', ['trump', 'election']);
```

---

## Conclusion

**For your project, stick with Supabase directly.** You don't need an ORM because:

1. âœ… Supabase provides type-safe queries
2. âœ… Query builder is intuitive and powerful
3. âœ… Real-time subscriptions are built-in
4. âœ… RLS provides database-level security
5. âœ… Your queries are already clean and maintainable
6. âœ… Adding an ORM would add complexity without much benefit

### Optional Enhancements

If you want more structure, consider:

1. **Create service/DAO layer** - Thin abstraction for common queries
2. **Use Supabase's generated types** - Already doing this âœ…
3. **Create custom hooks** - Already doing this âœ…
4. **Add query helpers** - Small utility functions for complex queries

**Bottom line:** Supabase is essentially a "lightweight ORM" that's perfect for your use case. No need to add Prisma, TypeORM, or Sequelize on top of it.
</file>

<file path="docs/supabase-dependency-analysis.md">
# Supabase Dependency Analysis: Vendor Lock-in Risks

## The Concern

As you build more features with Supabase, you become increasingly dependent on:
- Supabase's API layer (PostgREST)
- Supabase's real-time system
- Supabase's authentication (if you use it)
- Supabase's storage (if you use it)
- Supabase's dashboard and tooling

**Question:** Is this a problem? Should you be worried?

---

## What You're Actually Locked Into

### ðŸ”´ **Strong Lock-in (Hard to Migrate)**

1. **PostgREST API Layer**
   - Supabase's REST API is PostgREST (open source, but specific implementation)
   - Your queries use Supabase's query builder syntax
   - Real-time subscriptions are Supabase-specific
   - **Migration effort:** High - would need to rewrite all queries

2. **Supabase Real-time**
   - Uses Supabase's WebSocket infrastructure
   - Specific subscription API
   - **Migration effort:** High - would need to rebuild real-time layer

3. **Supabase Auth** (if you use it)
   - User management, JWT tokens, OAuth providers
   - **Migration effort:** High - would need new auth system

4. **Supabase Storage** (if you use it)
   - File uploads, CDN, image transformations
   - **Migration effort:** Medium-High - would need new storage solution

### ðŸŸ¡ **Medium Lock-in (Moderate Migration Effort)**

1. **Supabase Dashboard**
   - Database management, migrations UI, logs
   - **Migration effort:** Medium - can use standard PostgreSQL tools

2. **Supabase CLI**
   - Migration management, local development
   - **Migration effort:** Low-Medium - migrations are SQL, portable

3. **Supabase Client Library**
   - `@supabase/supabase-js` query builder
   - **Migration effort:** Medium - queries need rewriting but logic stays

### ðŸŸ¢ **Low Lock-in (Easy to Migrate)**

1. **PostgreSQL Database**
   - Standard PostgreSQL - completely portable
   - Your schema is just SQL
   - **Migration effort:** Low - can export/import to any PostgreSQL instance

2. **SQL Migrations**
   - Standard SQL files
   - **Migration effort:** Low - works with any PostgreSQL tool

3. **Row Level Security (RLS)**
   - Standard PostgreSQL feature
   - **Migration effort:** Low - works with any PostgreSQL

---

## The Reality Check

### **What You're Actually Using**

Looking at your current codebase:

```typescript
// âœ… Standard PostgreSQL queries (portable)
await supabase.from('markets').select('*').eq('status', 'open');

// âœ… Standard SQL migrations (portable)
// supabase/migrations/*.sql files

// âš ï¸ Supabase-specific real-time (lock-in)
supabase.channel('markets-changes').on('postgres_changes', ...)

// âœ… Standard PostgreSQL RLS (portable)
// RLS policies are just SQL
```

**Current lock-in level:** **Medium** - mostly using portable features

---

## Migration Strategies

### Strategy 1: Abstraction Layer (Recommended)

Create a thin abstraction layer that hides Supabase specifics:

```typescript
// lib/database.ts - Abstract database operations
export interface DatabaseClient {
  markets: {
    findAll(filters?: MarketFilters): Promise<Market[]>;
    findById(id: string): Promise<Market | null>;
    create(data: InsertMarket): Promise<Market>;
    update(id: string, data: UpdateMarket): Promise<Market>;
    subscribe(callback: (market: Market) => void): () => void;
  };
}

// lib/supabase-adapter.ts - Supabase implementation
export function createSupabaseClient(): DatabaseClient {
  return {
    markets: {
      async findAll(filters) {
        let query = supabase.from('markets').select('*');
        if (filters?.status) query = query.eq('status', filters.status);
        const { data } = await query;
        return data || [];
      },
      subscribe(callback) {
        const channel = supabase
          .channel('markets-changes')
          .on('postgres_changes', { table: 'markets' }, (payload) => {
            callback(payload.new as Market);
          })
          .subscribe();
        return () => supabase.removeChannel(channel);
      },
      // ... other methods
    }
  };
}

// lib/database.ts - Export the adapter
export const db = createSupabaseClient();
```

**Benefits:**
- âœ… All Supabase code in one place
- âœ… Easy to swap implementations
- âœ… Testable with mocks
- âœ… Can add other adapters (Prisma, TypeORM, raw SQL)

**Trade-offs:**
- âš ï¸ Extra abstraction layer (more code)
- âš ï¸ Need to maintain adapter
- âš ï¸ Might limit access to Supabase-specific features

### Strategy 2: Use Standard PostgreSQL Features Only

Stick to features that are pure PostgreSQL:

```typescript
// âœ… Use standard PostgreSQL features
// - Standard SQL queries
// - Standard RLS policies
// - Standard PostgreSQL functions

// âŒ Avoid Supabase-specific features
// - Supabase Auth (use your own auth)
// - Supabase Storage (use S3/Cloudflare)
// - Supabase Edge Functions (use your own backend)
```

**Benefits:**
- âœ… Maximum portability
- âœ… Can migrate to any PostgreSQL host
- âœ… Standard tooling works

**Trade-offs:**
- âš ï¸ Lose Supabase's convenience features
- âš ï¸ Need to build your own auth/storage

### Strategy 3: Accept the Lock-in (Pragmatic)

For many projects, vendor lock-in is acceptable:

**When this makes sense:**
- âœ… Supabase is open source (PostgREST, Realtime)
- âœ… Can self-host Supabase (Supabase is open source!)
- âœ… PostgreSQL is portable (your data is safe)
- âœ… Migration path exists (can export data, rewrite queries)

**Self-hosting Supabase:**
```bash
# Supabase is open source - you can self-host
docker-compose up -d
# Now you have your own Supabase instance
```

**Benefits:**
- âœ… Use all Supabase features freely
- âœ… Can self-host if needed
- âœ… Focus on building features, not infrastructure

**Trade-offs:**
- âš ï¸ Still need to maintain Supabase instance if self-hosting
- âš ï¸ Need to keep up with Supabase updates

---

## Risk Assessment

### **Low Risk Scenarios** (Don't worry)

1. **Early-stage startup/MVP**
   - Focus on building features
   - Can migrate later if needed
   - Supabase saves development time

2. **Small to medium apps**
   - Migration effort is manageable
   - Benefits outweigh risks

3. **Using mostly PostgreSQL features**
   - Your schema is portable
   - Can migrate to any PostgreSQL host

### **Medium Risk Scenarios** (Be cautious)

1. **Large, complex applications**
   - More code to migrate
   - More Supabase-specific features used
   - Consider abstraction layer

2. **Enterprise requirements**
   - May need specific compliance
   - May need on-premise hosting
   - Consider self-hosting Supabase

### **High Risk Scenarios** (Plan migration path)

1. **Regulated industries**
   - Healthcare, finance, government
   - May need specific hosting requirements
   - Plan for self-hosting or migration

2. **Very large scale**
   - May outgrow Supabase's managed service
   - Need custom infrastructure
   - Plan abstraction layer early

---

## Practical Recommendations

### For Your Project (Obsidian Market)

**Current state:**
- âœ… Using standard PostgreSQL features
- âœ… SQL migrations (portable)
- âœ… RLS policies (portable)
- âš ï¸ Using Supabase real-time (lock-in)
- âœ… Not using Supabase Auth (using wallet auth)
- âœ… Not using Supabase Storage (not needed yet)

**Recommendation: Option 1 - Light Abstraction Layer**

Create a thin abstraction for real-time subscriptions:

```typescript
// lib/realtime.ts - Abstract real-time
export interface RealtimeSubscription {
  unsubscribe: () => void;
}

export interface RealtimeClient {
  subscribeToMarkets(
    callback: (event: 'INSERT' | 'UPDATE' | 'DELETE', market: Market) => void
  ): RealtimeSubscription;
}

// lib/supabase-realtime.ts - Supabase implementation
export function createSupabaseRealtime(): RealtimeClient {
  return {
    subscribeToMarkets(callback) {
      const channel = supabase
        .channel('markets-changes')
        .on('postgres_changes', { table: 'markets' }, (payload) => {
          callback(payload.eventType, payload.new as Market);
        })
        .subscribe();
      
      return {
        unsubscribe: () => supabase.removeChannel(channel)
      };
    }
  };
}

// Usage
const realtime = createSupabaseRealtime();
const sub = realtime.subscribeToMarkets((event, market) => {
  // Handle update
});
// Later: sub.unsubscribe();
```

**Benefits:**
- âœ… Real-time code is abstracted
- âœ… Can swap implementations later
- âœ… Minimal overhead
- âœ… Rest of code stays clean

### Migration Path if Needed

If you ever need to migrate away from Supabase:

1. **Export your data** (standard PostgreSQL dump)
2. **Keep your SQL migrations** (they're portable)
3. **Rewrite query layer** (use Prisma, TypeORM, or raw SQL)
4. **Replace real-time** (use PostgreSQL LISTEN/NOTIFY or separate service)
5. **Deploy to new PostgreSQL host** (AWS RDS, DigitalOcean, etc.)

**Estimated effort:** 1-2 weeks for medium-sized app

---

## Comparison: Supabase vs Alternatives

### Supabase Lock-in vs Other Solutions

| Solution | Lock-in Level | Migration Effort | Self-hostable |
|----------|---------------|------------------|---------------|
| **Supabase** | Medium | Medium | âœ… Yes (open source) |
| **Firebase** | High | High | âŒ No |
| **Prisma + PostgreSQL** | Low | Low | âœ… Yes |
| **TypeORM + PostgreSQL** | Low | Low | âœ… Yes |
| **Raw SQL + PostgreSQL** | Very Low | Very Low | âœ… Yes |

**Key insight:** Supabase is more portable than Firebase, less portable than raw SQL, but provides more value than raw SQL.

---

## The Pragmatic Answer

### **Should you worry about Supabase lock-in?**

**Short answer:** **Not really, but plan for it.**

**Why:**

1. âœ… **Supabase is open source** - You can self-host if needed
2. âœ… **PostgreSQL is portable** - Your data and schema are safe
3. âœ… **Migration path exists** - Can export and migrate if needed
4. âœ… **You're using mostly portable features** - Standard PostgreSQL
5. âœ… **Early stage** - Focus on building, optimize later

### **What to do:**

1. **Create abstraction layer** for real-time subscriptions (lightweight)
2. **Keep SQL migrations** in standard format (you're doing this âœ…)
3. **Avoid Supabase-specific features** you don't need (Auth, Storage)
4. **Document your Supabase usage** so migration is easier if needed
5. **Consider self-hosting** if you outgrow managed service

### **When to worry:**

- âŒ If you're building a regulated/enterprise product (plan ahead)
- âŒ If you're using many Supabase-specific features (Auth, Storage, Edge Functions)
- âŒ If you're building something that must be vendor-agnostic

### **For your project:**

You're in a **low-risk** category:
- âœ… Early-stage prediction market
- âœ… Using mostly standard PostgreSQL
- âœ… Not using Supabase Auth/Storage
- âœ… Can migrate if needed (1-2 weeks effort)

**Recommendation:** **Don't worry about it now.** Focus on building features. Add a light abstraction layer for real-time if you want, but don't over-engineer it.

---

## Conclusion

**Supabase dependency is manageable:**

1. âœ… Most of what you use is portable PostgreSQL
2. âœ… Supabase is open source (can self-host)
3. âœ… Migration path exists if needed
4. âœ… Benefits (speed, real-time, RLS) outweigh risks for your use case

**Best practice:** Add a thin abstraction layer for real-time subscriptions, but don't over-engineer. Focus on building your product.

**Remember:** Perfect portability often means slower development. The right balance is using Supabase's features while keeping your core data portable (which you're doing âœ…).
</file>

<file path="docs/supabase-schema.md">
# Supabase Database Schema

## Overview

This document defines the database schema for Obsidian Market. The schema stores market metadata, admin information, and links to on-chain Aleo contract data.

## Tables

### markets

Stores prediction market metadata and configuration.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | UUID | PRIMARY KEY, DEFAULT uuid_generate_v4() | Unique market identifier |
| title | TEXT | NOT NULL | Market question/title |
| description | TEXT | | Market description and details |
| resolution_rules | TEXT | NOT NULL | Explicit criteria for how market resolves |
| resolution_source | TEXT | NOT NULL | Source of truth for resolution (e.g., "Admin manual") |
| resolution_deadline | TIMESTAMPTZ | NOT NULL | Date/time when market must be resolved by |
| status | TEXT | NOT NULL, CHECK (status IN ('open', 'closed', 'resolved', 'cancelled')) | Current market status |
| yes_odds | NUMERIC(10,2) | NOT NULL | Fixed odds for Yes outcome (e.g., 2.00) |
| no_odds | NUMERIC(10,2) | NOT NULL | Fixed odds for No outcome (e.g., 2.00) |
| creator_address | TEXT | NOT NULL | Admin wallet address who created the market |
| market_id_onchain | TEXT | UNIQUE | Market ID on Aleo blockchain (links to contract) |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | Market creation timestamp |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | Last update timestamp |

**Indexes:**
- `idx_markets_status` on `status` - For filtering by status
- `idx_markets_created_at` on `created_at DESC` - For sorting by newest
- `idx_markets_market_id_onchain` on `market_id_onchain` - For linking to on-chain data

### admins

Stores admin wallet addresses with permission to create markets.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| wallet_address | TEXT | PRIMARY KEY | Admin wallet address (Aleo address format) |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | When admin was added |

**Indexes:**
- Primary key on `wallet_address` provides fast lookup

## Row Level Security (RLS) Policies

### markets table

- **Public Read**: Anyone can read markets (SELECT)
- **Admin Write**: Only admins can create/update markets (INSERT, UPDATE)
- **No Delete**: Markets cannot be deleted (only status changed to 'cancelled')

### admins table

- **Public Read**: Anyone can read admin list (to check admin status)
- **Admin Write**: Only existing admins can add new admins (INSERT)
- **No Delete**: Admins cannot be deleted via API (manual DB operation only)

## SQL Migration Script

```sql
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create markets table
CREATE TABLE markets (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title TEXT NOT NULL,
    description TEXT,
    resolution_rules TEXT NOT NULL,
    resolution_source TEXT NOT NULL,
    resolution_deadline TIMESTAMPTZ NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('open', 'closed', 'resolved', 'cancelled')),
    yes_odds NUMERIC(10,2) NOT NULL CHECK (yes_odds > 0),
    no_odds NUMERIC(10,2) NOT NULL CHECK (no_odds > 0),
    creator_address TEXT NOT NULL,
    market_id_onchain TEXT UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create admins table
CREATE TABLE admins (
    wallet_address TEXT PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create indexes
CREATE INDEX idx_markets_status ON markets(status);
CREATE INDEX idx_markets_created_at ON markets(created_at DESC);
CREATE INDEX idx_markets_market_id_onchain ON markets(market_id_onchain);

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger for updated_at
CREATE TRIGGER update_markets_updated_at 
    BEFORE UPDATE ON markets
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Enable Row Level Security
ALTER TABLE markets ENABLE ROW LEVEL SECURITY;
ALTER TABLE admins ENABLE ROW LEVEL SECURITY;

-- RLS Policies for markets
-- Public read access
CREATE POLICY "Markets are viewable by everyone"
    ON markets FOR SELECT
    USING (true);

-- Admin write access (check if creator is admin)
CREATE POLICY "Admins can create markets"
    ON markets FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM admins 
            WHERE wallet_address = creator_address
        )
    );

-- Admin update access
CREATE POLICY "Admins can update markets"
    ON markets FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM admins 
            WHERE wallet_address = current_setting('request.jwt.claims', true)::json->>'wallet_address'
        )
    );

-- RLS Policies for admins
-- Public read access
CREATE POLICY "Admins list is viewable by everyone"
    ON admins FOR SELECT
    USING (true);

-- Admin write access (only existing admins can add)
CREATE POLICY "Admins can add other admins"
    ON admins FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM admins 
            WHERE wallet_address = current_setting('request.jwt.claims', true)::json->>'wallet_address'
        )
    );
```

## Notes

- The `market_id_onchain` field links Supabase records to Aleo contract state
- Status enum values: 'open', 'closed', 'resolved', 'cancelled'
- Odds are stored as numeric (e.g., 2.00 for 2:1 odds)
- RLS policies use JWT claims for authentication (will need to be configured with Supabase Auth or custom solution)
- For MVP, RLS policies may be simplified to allow public reads and admin-only writes via application logic
</file>

<file path="frontend/src/app/account/page.tsx">
'use client';

import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { useWallet } from '@/hooks/useWallet';

export default function AccountPage() {
  const { address, connected } = useWallet();

  return (
    <div className="min-h-screen bg-background">
      <div className="mx-auto max-w-5xl px-4 py-8">
        <Card>
          <CardHeader>
            <CardTitle className="text-2xl">My Account</CardTitle>
            <CardDescription>
              {connected
                ? `Connected: ${address}`
                : 'Connect your wallet to view account details.'}
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-muted-foreground">
              Wallet &amp; profile details will appear here.
            </p>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/app/settings/page.tsx">
'use client';

import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';

export default function SettingsPage() {
  return (
    <div className="min-h-screen bg-background">
      <div className="mx-auto max-w-5xl px-4 py-8">
        <Card>
          <CardHeader>
            <CardTitle className="text-2xl">Settings</CardTitle>
            <CardDescription>App configuration controls will live here.</CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-muted-foreground">
              App configuration controls will live here.
            </p>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";
@import "shadcn/tailwind.css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-3xl: calc(var(--radius) + 12px);
  --radius-4xl: calc(var(--radius) + 16px);
}

/* Light mode - Obsidian Market theme */
:root {
  --radius: 0.625rem;
  --background: oklch(0.98 0.002 247);     /* rgb(249,250,251) */
  --foreground: oklch(0.16 0.02 265);      /* rgb(17,24,39) */
  --card: oklch(1 0 0);                     /* rgb(255,255,255) */
  --card-foreground: oklch(0.16 0.02 265); /* rgb(17,24,39) */
  --popover: oklch(1 0 0);                  /* rgb(255,255,255) */
  --popover-foreground: oklch(0.16 0.02 265);
  --primary: oklch(0.55 0.2 260);           /* rgb(0,123,254) - blue */
  --primary-foreground: oklch(1 0 0);       /* white */
  --secondary: oklch(0.65 0.14 220);        /* rgb(45,175,231) */
  --secondary-foreground: oklch(1 0 0);
  --muted: oklch(0.965 0.002 247);          /* rgb(243,244,246) */
  --muted-foreground: oklch(0.55 0.015 260);/* rgb(107,114,128) */
  --accent: oklch(0.55 0.22 15);            /* rgb(255,40,84) - pink */
  --accent-foreground: oklch(1 0 0);
  --destructive: oklch(0.58 0.22 25);       /* rgb(239,68,68) */
  --border: oklch(0.92 0.004 265);          /* rgb(229,231,235) */
  --input: oklch(1 0 0);                    /* rgb(255,255,255) */
  --ring: oklch(0.92 0.004 265);            /* rgb(229,231,235) */
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.97 0.002 247);
  --sidebar-foreground: oklch(0.16 0.02 265);
  --sidebar-primary: oklch(0.55 0.2 260);
  --sidebar-primary-foreground: oklch(1 0 0);
  --sidebar-accent: oklch(0.965 0.002 247);
  --sidebar-accent-foreground: oklch(0.16 0.02 265);
  --sidebar-border: oklch(0.92 0.004 265);
  --sidebar-ring: oklch(0.55 0.2 260);
}

/* Dark mode - Obsidian theme */
.dark {
  --background: oklch(0.14 0 0);            /* #0a0a0a */
  --foreground: oklch(0.94 0.005 265);      /* #ECEDEE */
  --card: oklch(0.21 0 0);                  /* #1a1a1a */
  --card-foreground: oklch(0.94 0.005 265); /* #ECEDEE */
  --popover: oklch(0.21 0 0);               /* #1a1a1a */
  --popover-foreground: oklch(0.94 0.005 265);
  --primary: oklch(0.65 0.17 145);          /* #4CAF50 - obsidian green */
  --primary-foreground: oklch(1 0 0);       /* white */
  --secondary: oklch(0.30 0 0);             /* #333 */
  --secondary-foreground: oklch(0.94 0.005 265);
  --muted: oklch(0.30 0 0);                 /* #333 */
  --muted-foreground: oklch(0.67 0 0);      /* #999 */
  --accent: oklch(0.72 0.17 60);            /* #FF9800 - obsidian orange */
  --accent-foreground: oklch(1 0 0);
  --destructive: oklch(0.58 0.23 25);       /* #f44336 */
  --border: oklch(0.30 0 0);                /* #333 */
  --input: oklch(0.21 0 0);                 /* #1a1a1a */
  --ring: oklch(0.65 0.17 145);             /* #4CAF50 - obsidian green */
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.21 0 0);
  --sidebar-foreground: oklch(0.94 0.005 265);
  --sidebar-primary: oklch(0.65 0.17 145);
  --sidebar-primary-foreground: oklch(1 0 0);
  --sidebar-accent: oklch(0.30 0 0);
  --sidebar-accent-foreground: oklch(0.94 0.005 265);
  --sidebar-border: oklch(0.30 0 0);
  --sidebar-ring: oklch(0.65 0.17 145);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="frontend/src/app/layout.tsx">
import type { Metadata } from 'next';
import { Geist, Geist_Mono } from 'next/font/google';
import { Providers } from '@/components/layout/Providers';
import { Navbar } from '@/components/layout/Navbar';
import './globals.css';

const geistSans = Geist({
  variable: '--font-geist-sans',
  subsets: ['latin'],
});

const geistMono = Geist_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin'],
});

export const metadata: Metadata = {
  title: 'Obsidian Market',
  description: 'Privacy-focused prediction market built on Aleo',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Providers>
          <Navbar />
          <main>{children}</main>
        </Providers>
      </body>
    </html>
  );
}
</file>

<file path="frontend/src/app/page.tsx">
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { MarketList } from '@/components/MarketList';
import { CreateMarketForm } from '@/components/CreateMarketForm';
import { BetForm } from '@/components/BetForm';
import type { Market } from '@/types/supabase';

export default function HomePage() {
  const [selectedMarket, setSelectedMarket] = useState<Market | null>(null);
  const [showCreateForm, setShowCreateForm] = useState(false);

  return (
    <div className="min-h-screen bg-background">
      <div className="mx-auto max-w-5xl px-4 py-8">
        {selectedMarket ? (
          <div>
            <Button
              variant="ghost"
              className="mb-4"
              onClick={() => setSelectedMarket(null)}
            >
              &larr; Back to Markets
            </Button>
            <BetForm
              market={selectedMarket}
              onClose={() => setSelectedMarket(null)}
            />
          </div>
        ) : showCreateForm ? (
          <div>
            <Button
              variant="ghost"
              className="mb-4"
              onClick={() => setShowCreateForm(false)}
            >
              &larr; Back to Markets
            </Button>
            <CreateMarketForm onClose={() => setShowCreateForm(false)} />
          </div>
        ) : (
          <div>
            <div className="mb-6 flex items-center justify-between">
              <h1 className="text-2xl font-bold">Markets</h1>
              <Button onClick={() => setShowCreateForm(true)}>
                Create Market
              </Button>
            </div>
            <MarketList onMarketSelect={setSelectedMarket} />
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/layout/Navbar.tsx">
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { useTheme } from 'next-themes';
import { Sun, Moon } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { WalletButton } from '@/components/WalletButton';
import { cn } from '@/lib/utils';

const navLinks = [
  { href: '/', label: 'Home' },
  { href: '/account', label: 'Account' },
  { href: '/settings', label: 'Settings' },
];

export function Navbar() {
  const pathname = usePathname();
  const { theme, setTheme } = useTheme();

  return (
    <header className="border-b border-border bg-background px-6 py-4">
      <div className="mx-auto flex max-w-7xl items-center justify-between">
        <div className="flex items-center gap-8">
          <Link href="/" className="text-xl font-bold text-foreground">
            Obsidian Market
          </Link>
          <nav className="hidden items-center gap-1 sm:flex">
            {navLinks.map((link) => (
              <Link
                key={link.href}
                href={link.href}
                className={cn(
                  'rounded-md px-3 py-2 text-sm font-medium transition-colors',
                  pathname === link.href
                    ? 'bg-muted text-foreground'
                    : 'text-muted-foreground hover:text-foreground',
                )}
              >
                {link.label}
              </Link>
            ))}
          </nav>
        </div>
        <div className="flex items-center gap-3">
          <Button
            variant="ghost"
            size="icon"
            onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
            aria-label="Toggle theme"
          >
            <Sun className="size-4 scale-100 rotate-0 transition-transform dark:scale-0 dark:-rotate-90" />
            <Moon className="absolute size-4 scale-0 rotate-90 transition-transform dark:scale-100 dark:rotate-0" />
          </Button>
          <WalletButton />
        </div>
      </div>
    </header>
  );
}
</file>

<file path="frontend/src/components/layout/Providers.tsx">
'use client';

import { ThemeProvider } from 'next-themes';
import { WalletProvider } from '@/contexts/WalletContext';
import { Toaster } from '@/components/ui/sonner';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider attribute="class" defaultTheme="dark" enableSystem disableTransitionOnChange>
      <WalletProvider>
        {children}
        <Toaster />
      </WalletProvider>
    </ThemeProvider>
  );
}
</file>

<file path="frontend/src/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { Slot } from "radix-ui"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-full border border-transparent px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border-border text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
        ghost: "[a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
        link: "text-primary underline-offset-4 [a&]:hover:underline",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot.Root : "span"

  return (
    <Comp
      data-slot="badge"
      data-variant={variant}
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
</file>

<file path="frontend/src/components/ui/button.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { Slot } from "radix-ui"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        xs: "h-6 gap-1 rounded-md px-2 text-xs has-[>svg]:px-1.5 [&_svg:not([class*='size-'])]:size-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-xs": "size-6 rounded-md [&_svg:not([class*='size-'])]:size-3",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant = "default",
  size = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot.Root : "button"

  return (
    <Comp
      data-slot="button"
      data-variant={variant}
      data-size={size}
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="frontend/src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="frontend/src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import { XIcon } from "lucide-react"
import { Dialog as DialogPrimitive } from "radix-ui"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 outline-none sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({
  className,
  showCloseButton = false,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  showCloseButton?: boolean
}) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    >
      {children}
      {showCloseButton && (
        <DialogPrimitive.Close asChild>
          <Button variant="outline">Close</Button>
        </DialogPrimitive.Close>
      )}
    </div>
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="frontend/src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="frontend/src/components/ui/sonner.tsx">
"use client"

import {
  CircleCheckIcon,
  InfoIcon,
  Loader2Icon,
  OctagonXIcon,
  TriangleAlertIcon,
} from "lucide-react"
import { useTheme } from "next-themes"
import { Toaster as Sonner, type ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      icons={{
        success: <CircleCheckIcon className="size-4" />,
        info: <InfoIcon className="size-4" />,
        warning: <TriangleAlertIcon className="size-4" />,
        error: <OctagonXIcon className="size-4" />,
        loading: <Loader2Icon className="size-4 animate-spin" />,
      }}
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
          "--border-radius": "var(--radius)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="frontend/src/components/BetForm.tsx">
'use client';

import { useState, useCallback } from 'react';
import { Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent } from '@/components/ui/card';
import { useWallet } from '@/hooks/useWallet';
import { cn } from '@/lib/utils';
import type { Market } from '@/types/supabase';

interface BetFormProps {
  market: Market;
  onClose: () => void;
}

export function BetForm({ market, onClose }: BetFormProps) {
  const { address, connected } = useWallet();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [selectedSide, setSelectedSide] = useState<boolean | null>(null);
  const [betAmount, setBetAmount] = useState('1');

  const handlePlaceBet = useCallback(async () => {
    if (!connected || !address) {
      setError('Please connect your wallet first');
      return;
    }

    if (selectedSide === null) {
      setError('Please select Yes or No');
      return;
    }

    if (market.status !== 'open') {
      setError('This market is not accepting bets');
      return;
    }

    const amount = parseFloat(betAmount);
    if (isNaN(amount) || amount < 1) {
      setError('Minimum bet is 1 ALEO');
      return;
    }

    try {
      setLoading(true);
      setError(null);

      // TODO: Call Aleo place_bet transition
      // const amountMicrocredits = BigInt(Math.floor(amount * 1_000_000));

      onClose();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to place bet');
    } finally {
      setLoading(false);
    }
  }, [connected, address, selectedSide, betAmount, market, onClose]);

  const calculatePayout = (amount: number, side: boolean) => {
    const odds = side ? market.yes_odds : market.no_odds;
    return amount * odds;
  };

  return (
    <div className="mx-auto w-full max-w-2xl space-y-6">
      {/* Title and Description */}
      <div>
        <h1 className="mb-3 text-2xl font-bold">{market.title}</h1>
        {market.description && (
          <p className="leading-relaxed text-muted-foreground">
            {market.description}
          </p>
        )}
      </div>

      {/* Error Message */}
      {error && (
        <div className="rounded-md bg-destructive p-3">
          <p className="text-sm text-white">{error}</p>
        </div>
      )}

      {/* Warning Message */}
      {market.status !== 'open' && (
        <div className="rounded-md bg-accent p-3">
          <p className="text-sm text-accent-foreground">
            This market is {market.status} and not accepting bets
          </p>
        </div>
      )}

      {/* Prediction Selection */}
      <div>
        <h2 className="mb-4 text-lg font-semibold">Select Your Prediction</h2>
        <div className="grid grid-cols-2 gap-3">
          <button
            type="button"
            onClick={() => setSelectedSide(true)}
            className={cn(
              'flex flex-col items-center rounded-lg border p-4 transition-colors',
              selectedSide === true
                ? 'border-primary bg-primary text-primary-foreground'
                : 'border-border bg-card text-card-foreground hover:border-primary/50',
            )}
          >
            <span className="mb-2 text-lg font-semibold">Yes</span>
            <span
              className={cn(
                'mb-2 text-xs',
                selectedSide === true ? 'text-primary-foreground/80' : 'text-muted-foreground',
              )}
            >
              {market.yes_odds}x odds
            </span>
            {selectedSide === true && (
              <span className="text-xs font-semibold text-primary-foreground/90">
                Payout: {calculatePayout(parseFloat(betAmount) || 0, true).toFixed(2)} ALEO
              </span>
            )}
          </button>
          <button
            type="button"
            onClick={() => setSelectedSide(false)}
            className={cn(
              'flex flex-col items-center rounded-lg border p-4 transition-colors',
              selectedSide === false
                ? 'border-primary bg-primary text-primary-foreground'
                : 'border-border bg-card text-card-foreground hover:border-primary/50',
            )}
          >
            <span className="mb-2 text-lg font-semibold">No</span>
            <span
              className={cn(
                'mb-2 text-xs',
                selectedSide === false ? 'text-primary-foreground/80' : 'text-muted-foreground',
              )}
            >
              {market.no_odds}x odds
            </span>
            {selectedSide === false && (
              <span className="text-xs font-semibold text-primary-foreground/90">
                Payout: {calculatePayout(parseFloat(betAmount) || 0, false).toFixed(2)} ALEO
              </span>
            )}
          </button>
        </div>
      </div>

      {/* Bet Amount Input */}
      <div>
        <label className="mb-2 block text-sm font-semibold">Bet Amount (ALEO)</label>
        <Input
          type="number"
          min="1"
          step="0.1"
          value={betAmount}
          onChange={(e) => setBetAmount(e.target.value)}
          placeholder="1"
          className="mb-2"
        />
        <p className="text-xs text-muted-foreground">Minimum: 1 ALEO</p>
      </div>

      {/* Summary */}
      {selectedSide !== null && (
        <Card>
          <CardContent className="py-4">
            <p className="text-sm">
              Betting {betAmount || '0'} ALEO on{' '}
              <span className="font-semibold">{selectedSide ? 'Yes' : 'No'}</span>
            </p>
            <p className="text-sm">
              Potential Payout:{' '}
              <span className="font-semibold">
                {calculatePayout(parseFloat(betAmount) || 0, selectedSide).toFixed(2)} ALEO
              </span>
            </p>
          </CardContent>
        </Card>
      )}

      {/* Action Buttons */}
      <div className="flex gap-3">
        <Button
          className="flex-1"
          onClick={handlePlaceBet}
          disabled={loading || selectedSide === null || market.status !== 'open'}
        >
          {loading && <Loader2 className="size-4 animate-spin" />}
          Place Bet
        </Button>
        <Button variant="secondary" className="flex-1" onClick={onClose}>
          Cancel
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/CreateMarketForm.tsx">
'use client';

import { useState, useCallback } from 'react';
import { Loader2 } from 'lucide-react';
import { useWallet } from '@/hooks/useWallet';
import { useAdmin } from '@/hooks/useAdmin';
import { supabase } from '@/lib/supabase';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

interface CreateMarketFormProps {
  onClose: () => void;
}

export function CreateMarketForm({ onClose }: CreateMarketFormProps) {
  const { address, connected } = useWallet();
  const { isAdmin, loading: adminLoading } = useAdmin(address);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [formData, setFormData] = useState({
    title: '',
    description: '',
    resolution_rules: '',
    resolution_source: 'Admin manual',
    resolution_deadline: '',
    yes_odds: '2.0',
    no_odds: '2.0',
  });

  const handleChange = useCallback(
    (field: string, value: string) => {
      setFormData((prev) => ({ ...prev, [field]: value }));
    },
    [],
  );

  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault();

      if (!connected || !address) {
        setError('Please connect your wallet first');
        return;
      }

      if (!isAdmin) {
        setError('Only admins can create markets');
        return;
      }

      if (!formData.title || !formData.resolution_rules || !formData.resolution_deadline) {
        setError('Please fill in all required fields');
        return;
      }

      try {
        setLoading(true);
        setError(null);

        const marketId = Date.now();

        const { error: supabaseError } = await supabase.from('markets').insert({
          title: formData.title,
          description: formData.description || null,
          resolution_rules: formData.resolution_rules,
          resolution_source: formData.resolution_source,
          resolution_deadline: formData.resolution_deadline,
          status: 'open',
          yes_odds: parseFloat(formData.yes_odds),
          no_odds: parseFloat(formData.no_odds),
          creator_address: address,
          market_id_onchain: marketId.toString(),
        });

        if (supabaseError) {
          throw supabaseError;
        }

        onClose();
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to create market');
      } finally {
        setLoading(false);
      }
    },
    [connected, address, isAdmin, formData, onClose],
  );

  if (adminLoading) {
    return (
      <div className="flex flex-col items-center justify-center p-10">
        <Loader2 className="size-8 animate-spin text-primary" />
        <p className="mt-3 text-muted-foreground">Checking admin status...</p>
      </div>
    );
  }

  if (!isAdmin) {
    return (
      <div className="flex items-center justify-center p-10">
        <p className="text-destructive">Only admins can create markets</p>
      </div>
    );
  }

  return (
    <Card className="mx-auto w-full max-w-2xl">
      <CardHeader>
        <CardTitle className="text-2xl">Create New Market</CardTitle>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          {error && (
            <div className="rounded-md bg-destructive p-3">
              <p className="text-sm text-white">{error}</p>
            </div>
          )}

          <div className="space-y-2">
            <label className="text-sm font-semibold">Title *</label>
            <Input
              value={formData.title}
              onChange={(e) => handleChange('title', e.target.value)}
              placeholder="Will Bitcoin reach $100k by end of 2024?"
            />
          </div>

          <div className="space-y-2">
            <label className="text-sm font-semibold">Description</label>
            <textarea
              value={formData.description}
              onChange={(e) => handleChange('description', e.target.value)}
              placeholder="Additional details about the market..."
              rows={3}
              className="border-input bg-transparent placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 w-full rounded-md border px-3 py-2 text-sm shadow-xs focus-visible:ring-[3px]"
            />
          </div>

          <div className="space-y-2">
            <label className="text-sm font-semibold">Resolution Rules *</label>
            <textarea
              value={formData.resolution_rules}
              onChange={(e) => handleChange('resolution_rules', e.target.value)}
              placeholder="How will this market be resolved?"
              rows={3}
              className="border-input bg-transparent placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 w-full rounded-md border px-3 py-2 text-sm shadow-xs focus-visible:ring-[3px]"
            />
          </div>

          <div className="space-y-2">
            <label className="text-sm font-semibold">Resolution Deadline *</label>
            <Input
              type="datetime-local"
              value={formData.resolution_deadline}
              onChange={(e) => handleChange('resolution_deadline', e.target.value)}
            />
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <label className="text-sm font-semibold">Yes Odds</label>
              <Input
                type="number"
                step="0.1"
                min="1"
                value={formData.yes_odds}
                onChange={(e) => handleChange('yes_odds', e.target.value)}
                placeholder="2.0"
              />
            </div>
            <div className="space-y-2">
              <label className="text-sm font-semibold">No Odds</label>
              <Input
                type="number"
                step="0.1"
                min="1"
                value={formData.no_odds}
                onChange={(e) => handleChange('no_odds', e.target.value)}
                placeholder="2.0"
              />
            </div>
          </div>

          <div className="flex gap-3 pt-2">
            <Button type="submit" className="flex-1" disabled={loading}>
              {loading && <Loader2 className="size-4 animate-spin" />}
              Create Market
            </Button>
            <Button type="button" variant="secondary" className="flex-1" onClick={onClose}>
              Cancel
            </Button>
          </div>
        </form>
      </CardContent>
    </Card>
  );
}
</file>

<file path="frontend/src/components/MarketCard.tsx">
'use client';

import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
  CardDescription,
  CardAction,
} from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { cn } from '@/lib/utils';
import type { Market } from '@/types/supabase';

interface MarketCardProps {
  market: Market;
  onSelect?: (market: Market) => void;
}

const statusVariant: Record<Market['status'], string> = {
  open: 'bg-primary text-primary-foreground',
  closed: 'bg-accent text-accent-foreground',
  resolved: 'bg-blue-500 text-white',
  cancelled: 'bg-destructive text-white',
};

function formatDeadline(deadline: string) {
  return new Date(deadline).toLocaleDateString();
}

export function MarketCard({ market, onSelect }: MarketCardProps) {
  return (
    <Card
      className={cn('transition-colors', onSelect && 'cursor-pointer hover:border-primary/50')}
      onClick={() => onSelect?.(market)}
    >
      <CardHeader>
        <CardTitle className="line-clamp-2">{market.title}</CardTitle>
        <CardAction>
          <Badge className={cn('border-0', statusVariant[market.status])}>
            {market.status.toUpperCase()}
          </Badge>
        </CardAction>
        {market.description && (
          <CardDescription className="line-clamp-3">
            {market.description}
          </CardDescription>
        )}
      </CardHeader>

      <CardContent>
        <div className="flex gap-6">
          <div>
            <p className="text-xs text-muted-foreground">Yes Odds</p>
            <p className="text-base font-bold">{market.yes_odds}x</p>
          </div>
          <div>
            <p className="text-xs text-muted-foreground">No Odds</p>
            <p className="text-base font-bold">{market.no_odds}x</p>
          </div>
        </div>
      </CardContent>

      <CardFooter className="justify-between">
        <p className="text-xs text-muted-foreground">
          Deadline: {formatDeadline(market.resolution_deadline)}
        </p>
        {market.market_id_onchain && (
          <p className="text-xs text-muted-foreground/60">
            ID: {market.market_id_onchain}
          </p>
        )}
      </CardFooter>
    </Card>
  );
}
</file>

<file path="frontend/src/components/MarketList.tsx">
'use client';

import { Loader2 } from 'lucide-react';
import { useMarkets } from '@/hooks/useMarkets';
import { MarketCard } from './MarketCard';
import type { Market, MarketStatus } from '@/types/supabase';

interface MarketListProps {
  onMarketSelect?: (market: Market) => void;
  statusFilter?: MarketStatus;
}

export function MarketList({ onMarketSelect, statusFilter }: MarketListProps) {
  const { markets, loading, error } = useMarkets(statusFilter);

  if (loading) {
    return (
      <div className="flex flex-col items-center justify-center p-10">
        <Loader2 className="size-8 animate-spin text-primary" />
        <p className="mt-3 text-muted-foreground">Loading markets...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center p-10">
        <p className="text-destructive">
          Error loading markets: {error.message}
        </p>
      </div>
    );
  }

  if (markets.length === 0) {
    return (
      <div className="flex items-center justify-center p-10">
        <p className="text-muted-foreground">No markets found</p>
      </div>
    );
  }

  return (
    <div className="grid gap-4">
      {markets.map((market) => (
        <MarketCard key={market.id} market={market} onSelect={onMarketSelect} />
      ))}
    </div>
  );
}
</file>

<file path="frontend/src/components/WalletButton.tsx">
'use client';

import { useCallback, useState } from 'react';
import { useWallet } from '@/hooks/useWallet';
import { Button } from '@/components/ui/button';

export function WalletButton() {
  const { address, connected, connect, disconnect } = useWallet();
  const [error, setError] = useState<string | null>(null);

  const handleClick = useCallback(async () => {
    if (connected) {
      disconnect();
    } else {
      try {
        setError(null);
        await connect();
      } catch (error) {
        console.error('Failed to connect wallet:', error);
        const errorMessage =
          error instanceof Error ? error.message : 'Failed to connect wallet';
        setError(errorMessage);
      }
    }
  }, [connected, connect, disconnect]);

  return (
    <div>
      {error && (
        <div className="absolute top-16 right-4 z-50 max-w-sm rounded-lg bg-destructive px-4 py-2 text-sm text-white shadow-lg">
          {error}
        </div>
      )}
      <Button
        variant={connected ? 'destructive' : 'default'}
        size="sm"
        onClick={handleClick}
      >
        {connected
          ? `Disconnect (${address?.slice(0, 8)}...)`
          : 'Connect Wallet'}
      </Button>
    </div>
  );
}
</file>

<file path="frontend/src/contexts/WalletContext.tsx">
'use client';

import {
  createContext,
  useContext,
  useCallback,
  useMemo,
  type ReactNode,
} from 'react';
import {
  AleoWalletProvider,
  useWallet as useProvableWallet,
} from '@provablehq/aleo-wallet-adaptor-react';
import { LeoWalletAdapter } from '@provablehq/aleo-wallet-adaptor-leo';
import { DecryptPermission } from '@provablehq/aleo-wallet-adaptor-core';
import { Network } from '@provablehq/aleo-types';

interface WalletContextType {
  address: string | null;
  connected: boolean;
  connect: () => Promise<void>;
  disconnect: () => void;
  signMessage: (message: string) => Promise<string | null>;
}

const WalletContext = createContext<WalletContextType | undefined>(undefined);

function WalletProviderInner({ children }: { children: ReactNode }) {
  const provable = useProvableWallet();

  const connect = useCallback(async () => {
    try {
      // Select Leo Wallet, then connect to testnet
      provable.selectWallet('Leo Wallet' as never);
      await provable.connect(Network.TESTNET);
    } catch (error) {
      console.error('Wallet connection error:', error);
      throw error;
    }
  }, [provable]);

  const disconnect = useCallback(() => {
    provable.disconnect();
  }, [provable]);

  const signMessage = useCallback(
    async (message: string): Promise<string | null> => {
      if (!provable.connected || !provable.address) {
        throw new Error('Wallet not connected');
      }
      const bytes = new TextEncoder().encode(message);
      const signatureBytes = await provable.signMessage(bytes);
      if (!signatureBytes) return null;
      return new TextDecoder().decode(signatureBytes);
    },
    [provable],
  );

  return (
    <WalletContext.Provider
      value={{
        address: provable.address,
        connected: provable.connected,
        connect,
        disconnect,
        signMessage,
      }}
    >
      {children}
    </WalletContext.Provider>
  );
}

export function WalletProvider({ children }: { children: ReactNode }) {
  const wallets = useMemo(() => {
    try {
      return [
        new LeoWalletAdapter({
          appName: 'Obsidian Market',
        }),
      ];
    } catch (error) {
      console.warn('Failed to create wallet adapter:', error);
      return [];
    }
  }, []);

  return (
    <AleoWalletProvider
      wallets={wallets}
      decryptPermission={DecryptPermission.UponRequest}
      network={Network.TESTNET}
      autoConnect
    >
      <WalletProviderInner>{children}</WalletProviderInner>
    </AleoWalletProvider>
  );
}

export function useWallet() {
  const context = useContext(WalletContext);
  if (context === undefined) {
    throw new Error('useWallet must be used within a WalletProvider');
  }
  return context;
}
</file>

<file path="frontend/src/hooks/useAdmin.ts">
'use client';

import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';

export function useAdmin(walletAddress: string | null) {
  const [isAdmin, setIsAdmin] = useState(false);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const checkAdmin = async () => {
      if (!walletAddress) {
        setIsAdmin(false);
        setLoading(false);
        return;
      }

      try {
        setLoading(true);
        const { data, error: fetchError } = await supabase
          .from('admins')
          .select('wallet_address')
          .eq('wallet_address', walletAddress)
          .single();

        if (fetchError && fetchError.code !== 'PGRST116') {
          throw fetchError;
        }

        setIsAdmin(!!data);
        setError(null);
      } catch (err) {
        setError(
          err instanceof Error
            ? err
            : new Error('Failed to check admin status'),
        );
        setIsAdmin(false);
      } finally {
        setLoading(false);
      }
    };

    checkAdmin();
  }, [walletAddress]);

  return { isAdmin, loading, error };
}
</file>

<file path="frontend/src/hooks/useMarkets.ts">
'use client';

import { useEffect, useState } from 'react';
import { supabase } from '@/lib/supabase';
import type { Market, MarketStatus } from '@/types/supabase';

export function useMarkets(status?: MarketStatus) {
  const [markets, setMarkets] = useState<Market[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const fetchMarkets = async () => {
      try {
        setLoading(true);
        let query = supabase
          .from('markets')
          .select('*')
          .order('created_at', { ascending: false });

        if (status) {
          query = query.eq('status', status);
        }

        const { data, error: fetchError } = await query;

        if (fetchError) {
          throw fetchError;
        }

        setMarkets(data || []);
        setError(null);
      } catch (err) {
        setError(
          err instanceof Error ? err : new Error('Failed to fetch markets'),
        );
        setMarkets([]);
      } finally {
        setLoading(false);
      }
    };

    fetchMarkets();

    const channel = supabase
      .channel('markets-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'markets',
        },
        (payload) => {
          if (payload.eventType === 'INSERT') {
            setMarkets((prev) => [payload.new as Market, ...prev]);
          } else if (payload.eventType === 'UPDATE') {
            setMarkets((prev) =>
              prev.map((market) =>
                market.id === payload.new.id ? (payload.new as Market) : market,
              ),
            );
          } else if (payload.eventType === 'DELETE') {
            setMarkets((prev) =>
              prev.filter((market) => market.id !== payload.old.id),
            );
          }
        },
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [status]);

  return { markets, loading, error, refetch: () => {} };
}
</file>

<file path="frontend/src/hooks/useWallet.ts">
'use client';

export { useWallet } from '@/contexts/WalletContext';
</file>

<file path="frontend/src/lib/supabase.ts">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error(
    'Missing Supabase environment variables. Please set NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY in your .env.local file',
  );
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
</file>

<file path="frontend/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="frontend/src/types/supabase.ts">
export type MarketStatus = 'open' | 'closed' | 'resolved' | 'cancelled';

export interface Market {
  id: string;
  title: string;
  description: string | null;
  resolution_rules: string;
  resolution_source: string;
  resolution_deadline: string;
  status: MarketStatus;
  yes_odds: number;
  no_odds: number;
  creator_address: string;
  market_id_onchain: string | null;
  created_at: string;
  updated_at: string;
}

export interface Admin {
  wallet_address: string;
  created_at: string;
}

export interface Database {
  public: {
    Tables: {
      markets: {
        Row: Market;
        Insert: Omit<Market, 'id' | 'created_at' | 'updated_at'>;
        Update: Partial<Omit<Market, 'id' | 'created_at'>>;
      };
      admins: {
        Row: Admin;
        Insert: Omit<Admin, 'created_at'>;
        Update: Partial<Admin>;
      };
    };
  };
}
</file>

<file path="frontend/.npmrc">
legacy-peer-deps=true
</file>

<file path="frontend/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "rtl": false,
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}
</file>

<file path="frontend/eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="frontend/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="frontend/postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="CHANGELOG.md">
# Changelog

## v1.0.0

### Added or Changed
- Added this changelog :)
- Fixed typos in both templates
- Back to top links
- Added more "Built With" frameworks/libraries
- Changed table of contents to start collapsed
- Added checkboxes for major features on roadmap

### Removed

- Some packages/libraries from acknowledgements I no longer use
</file>

<file path="CLAUDE.md">
# Obsidian Market

Privacy-focused prediction market built on Aleo.

## Architecture

- **frontend/** - Next.js (App Router) web app with shadcn/ui + Tailwind CSS
- **backend/** - Supabase (PostgreSQL) for market metadata, real-time subscriptions
- **aleo/** - Leo smart contract (`obsidian_market.aleo`) for on-chain market logic and private betting

## Smart Contract

- Program: `obsidian_market.aleo`
- Deployed on testnet: https://testnet.explorer.provable.com/program/obsidian_market.aleo
- Admin address: `aleo1awc7l4v56ahsjyj29g4fe3f8ps4w3akzy305vymlzm3exawgvypqk78elv`
- Uses CPMM (constant product AMM) for pricing
- BetRecords are private (users hold positions privately)

## Key Commands

```bash
# Smart contract (run from aleo/ directory)
leo build                              # Compile the program
leo deploy --broadcast --yes           # Deploy to testnet
leo execute <fn> <args> --broadcast --yes  # Execute a transition
leo test                               # Run tests

# Query on-chain state
curl https://api.explorer.provable.com/v1/testnet/program/obsidian_market.aleo/mapping/markets/<id>

# Frontend (run from frontend/ directory)
npm run dev                            # Start dev server
npm run build                          # Production build

# Backend
supabase start                         # Start local Supabase
```

## Environment

- Network: testnet
- Endpoint: https://api.explorer.provable.com/v1
- Leo CLI: 3.4.0
- `.env` files contain private keys - never commit them

## Conventions

- Always use `--broadcast --yes` flags when deploying/executing via CLI (non-interactive)
- The `@admin` address in main.leo must match the deploying wallet
- For `leo test`, the `@admin` address must match the test private key (test ledger only has credits for standard dev keys)
</file>

<file path="backend/supabase/config.toml">
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "backend"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false
# Paths to self-signed certificate pair.
# cert_path = "../certs/my-cert.pem"
# key_path = "../certs/my-key.pem"

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 17

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# If disabled, migrations will be skipped during a db push or reset.
enabled = true
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[db.network_restrictions]
# Enable management of network restrictions.
enabled = false
# List of IPv4 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv4 connections. Set empty array to block all IPs.
allowed_cidrs = ["0.0.0.0/0"]
# List of IPv6 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv6 connections. Set empty array to block all IPs.
allowed_cidrs_v6 = ["::/0"]

[realtime]
enabled = false
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = false
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# JWT issuer URL. If not set, defaults to the local API URL (http://127.0.0.1:<port>/auth/v1).
# jwt_issuer = ""
# Path to JWT signing key. DO NOT commit your signing keys file to git.
# signing_keys_path = "./signing_keys.json"
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

# Uncomment to customize notification email template
# [auth.email.notification.password_changed]
# enabled = true
# subject = "Your password has been changed"
# content_path = "./templates/password_changed_notification.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a new user is created and allows developers to reject the request based on the incoming user object.
# [auth.hook.before_user_created]
# enabled = true
# uri = "pg-functions://postgres/auth/before-user-created-hook"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false
# If enabled, it will allow the user to successfully authenticate when the provider does not return an email address.
email_optional = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

# OAuth server configuration
[auth.oauth_server]
# Enable OAuth server functionality
enabled = false
# Path for OAuth consent flow UI
authorization_url_path = "/oauth/consent"
# Allow dynamic client registration
allow_dynamic_registration = false

[edge_runtime]
enabled = false
# Supported request policies: `oneshot`, `per_worker`.
# `per_worker` (default) â€” enables hot reload during local development.
# `oneshot` â€” fallback mode if hot reload causes issues (e.g. in large repos or with symlinks).
policy = "per_worker"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 2

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = false
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
</file>

<file path="docs/deployment.md">
# Deployment Guide

## Overview

This guide covers deploying Obsidian Market to production, including:
- Supabase production setup
- Aleo testnet deployment
- Frontend deployment
- Environment configuration

## Prerequisites

- Supabase project (production)
- Aleo testnet account with credits
- Deployment platform (Vercel, Netlify, etc.)

## Phase 1: Supabase Production Setup

### 1. Create Production Project

1. Go to [Supabase Dashboard](https://supabase.com/dashboard)
2. Create new project (or use existing)
3. Note down:
   - Project URL
   - Anon key
   - Service role key (keep secret!)

### 2. Run Migration Scripts

1. Go to SQL Editor in Supabase dashboard
2. Run migration from `docs/supabase-schema.md`
3. Verify tables created:
   - `markets`
   - `admins`

### 3. Configure Row Level Security

1. Review RLS policies in migration script
2. Adjust policies for production needs
3. Test with anon key

### 4. Add Admin Addresses

```sql
INSERT INTO admins (wallet_address) 
VALUES ('aleo1...'); -- Your admin address
```

## Phase 2: Aleo Testnet Deployment

### 1. Prepare Leo Program

```bash
cd leo
leo build
```

This creates `build/main.aleo` ready for deployment.

### 2. Deploy to Testnet

```bash
# Deploy using Leo CLI (when available)
leo deploy --network testnet

# Or use Aleo SDK/CLI tools
# Follow Aleo deployment documentation
```

### 3. Note Contract Address

After deployment, save:
- Contract address
- Program ID
- Deployment transaction hash

### 4. Update Frontend

Update contract address in frontend code (create config file):

```typescript
// frontend/src/config/aleo.ts
export const ALEO_CONTRACT_ADDRESS = 'aleo1...'
export const ALEO_NETWORK = 'testnet'
```

## Phase 3: Frontend Deployment

### Option A: Vercel

1. Install Vercel CLI:
   ```bash
   npm i -g vercel
   ```

2. Deploy:
   ```bash
   cd frontend
   vercel
   ```

3. Set environment variables in Vercel dashboard:
   - `VITE_SUPABASE_URL`
   - `VITE_SUPABASE_ANON_KEY`
   - `VITE_ALEO_CONTRACT_ADDRESS` (if using)

### Option B: Netlify

1. Install Netlify CLI:
   ```bash
   npm i -g netlify-cli
   ```

2. Deploy:
   ```bash
   cd frontend
   netlify deploy --prod
   ```

3. Set environment variables in Netlify dashboard

### Option C: Static Hosting

1. Build for production:
   ```bash
   cd frontend
   pnpm run build
   ```

2. Deploy `dist/` folder to:
   - GitHub Pages
   - AWS S3 + CloudFront
   - Any static hosting service

### Environment Variables

Set these in your deployment platform:

```env
VITE_SUPABASE_URL=https://xxxxx.supabase.co
VITE_SUPABASE_ANON_KEY=eyJ...
VITE_ALEO_CONTRACT_ADDRESS=aleo1...
VITE_ALEO_NETWORK=testnet
```

## Phase 4: Post-Deployment

### 1. Verify Deployment

- [ ] Supabase tables accessible
- [ ] Frontend loads correctly
- [ ] Wallet connection works
- [ ] Market creation works (admin)
- [ ] Bet placement works

### 2. Monitor

- Supabase dashboard: Check database usage
- Aleo explorer: Monitor contract transactions
- Frontend: Check error logs

### 3. Security Checklist

- [ ] RLS policies configured
- [ ] Admin addresses verified
- [ ] Environment variables secured
- [ ] No secrets in client code
- [ ] HTTPS enabled

## Testing Production

### 1. Test Market Creation

1. Connect admin wallet
2. Create test market
3. Verify in Supabase
4. Verify on-chain

### 2. Test Betting

1. Connect user wallet
2. Place test bet
3. Verify transaction on Aleo
4. Check Supabase updates

### 3. Test Resolution

1. As admin, resolve market
2. Verify payouts distributed
3. Check market status updated

## Troubleshooting

### Supabase Issues

- Check RLS policies
- Verify API keys
- Check database connection limits

### Aleo Issues

- Verify network (testnet/mainnet)
- Check contract address
- Verify transaction fees

### Frontend Issues

- Check environment variables
- Verify build output
- Check browser console for errors

## Rollback Plan

If issues occur:

1. **Supabase**: Restore from backup (if configured)
2. **Aleo**: Contract is immutable, but can deploy new version
3. **Frontend**: Revert to previous deployment

## Future: Mainnet Deployment

When ready for mainnet:

1. **Security Audit**: Get smart contracts audited
2. **Test Thoroughly**: Extensive testing on testnet
3. **Deploy Contract**: Deploy to Aleo mainnet
4. **Update Frontend**: Point to mainnet contract
5. **Monitor Closely**: Watch for issues

## Resources

- [Supabase Deployment](https://supabase.com/docs/guides/hosting)
- [Aleo Deployment](https://developer.aleo.org/testnet/getting_started/)
- [Vercel Deployment](https://vercel.com/docs)
- [Netlify Deployment](https://docs.netlify.com/)
</file>

<file path="docs/development.md">
# Development Guide

## Prerequisites

- Node.js >= 18
- pnpm (package manager)
- Leo CLI (for smart contract development)
- Supabase account (for database)

## Setup

### 1. Clone and Install Dependencies

```bash
# Install frontend dependencies
cd frontend
pnpm install

# Install Leo CLI (if not already installed)
# See: https://developer.aleo.org/leo/installation
```

### 2. Configure Environment Variables

Create `frontend/.env` file:

```env
VITE_SUPABASE_URL=https://xxxxx.supabase.co
VITE_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### 3. Set Up Supabase

1. Follow the [Supabase Setup Guide](./supabase-setup.md)
2. Run the migration scripts to create tables
3. Add your admin wallet address to the `admins` table

### 4. Set Up Aleo Local Development

1. Follow the [Aleo Local Development Guide](./aleo-local-dev.md)
2. Build and test the Leo program:
   ```bash
   cd leo
   leo build
   leo test
   ```

## Development Workflow

### Frontend Development

Start the development server:

```bash
cd frontend
pnpm run dev
```

This starts the Lynx dev server on `http://localhost:3000`. You can:
- View in browser (web wrapper)
- Scan QR code with LynxExplorer app (mobile)

### Smart Contract Development

1. Edit `leo/src/main.leo`
2. Build: `leo build`
3. Test: `leo test`
4. Deploy locally (when SnarkVM is set up)

### Testing

Run frontend tests:

```bash
cd frontend
pnpm test
```

## Project Structure

```
obsidian-market/
â”œâ”€â”€ leo/                    # Aleo smart contracts
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â””â”€â”€ main.leo       # Main contract
â”‚   â””â”€â”€ tests/
â”‚       â””â”€â”€ test_leo.leo   # Contract tests
â”œâ”€â”€ frontend/              # Frontend application
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/   # React/Lynx components
â”‚   â”‚   â”œâ”€â”€ contexts/     # React contexts (Wallet)
â”‚   â”‚   â”œâ”€â”€ hooks/        # Custom React hooks
â”‚   â”‚   â”œâ”€â”€ lib/          # Utilities (Supabase client)
â”‚   â”‚   â””â”€â”€ types/        # TypeScript types
â”‚   â””â”€â”€ package.json
â””â”€â”€ docs/                  # Documentation
```

## Key Components

### Frontend

- **App.tsx**: Main application component with routing
- **WalletContext**: Manages wallet connection state
- **MarketList**: Displays list of markets from Supabase
- **CreateMarketForm**: Admin form to create new markets
- **BetForm**: Form to place bets on markets

### Smart Contracts

- **create_market**: Admin creates new prediction market
- **place_bet**: User places bet on market
- **get_market**: Query market state
- **get_bet**: Query bet information

## Common Tasks

### Adding a New Market (Admin)

1. Connect wallet (must be admin)
2. Click "Create Market"
3. Fill in form fields
4. Submit (creates in Supabase, then on-chain)

### Placing a Bet

1. Connect wallet
2. Select a market
3. Choose Yes/No
4. Enter bet amount (minimum 1 ALEO)
5. Submit transaction

### Testing Smart Contracts

```bash
cd leo
leo test
```

## Troubleshooting

### Supabase Connection Issues

- Verify environment variables are set
- Check Supabase project is active
- Verify RLS policies allow access

### Wallet Connection Issues

- Ensure Leo Wallet extension is installed (for web)
- Check wallet is unlocked
- Verify network (testnet/mainnet) matches

### Build Errors

- Clear `leo/build` directory and rebuild
- Check Leo version matches `program.json`
- Verify all dependencies installed

## Next Steps

1. Complete Aleo wallet integration
2. Implement on-chain market creation
3. Implement on-chain bet placement
4. Add market resolution functionality
5. Deploy to testnet

## Resources

- [Leo Language Docs](https://developer.aleo.org/leo/)
- [Lynx Framework Docs](https://lynx-js.github.io/)
- [Supabase Docs](https://supabase.com/docs)
</file>

<file path="docs/supabase-setup.md">
# Supabase Setup Guide

## Prerequisites

- A Supabase account (sign up at https://supabase.com)
- Basic knowledge of SQL and database concepts

## Step 1: Create Supabase Project

1. Go to https://supabase.com and sign in
2. Click "New Project"
3. Fill in project details:
   - **Name**: `obsidian-market` (or your preferred name)
   - **Database Password**: Choose a strong password (save this!)
   - **Region**: Select closest region
   - **Pricing Plan**: Free tier is sufficient for MVP
4. Click "Create new project"
5. Wait 2-3 minutes for project to initialize

## Step 2: Get Project Credentials

1. In your Supabase project dashboard, go to **Settings** â†’ **API**
2. Copy the following values (you'll need these for environment variables):
   - **Project URL** (e.g., `https://xxxxx.supabase.co`)
   - **anon/public key** (starts with `eyJ...`)
   - **service_role key** (keep this secret! Only for server-side use)

## Step 3: Run Database Migration

1. In Supabase dashboard, go to **SQL Editor**
2. Click "New query"
3. Copy the SQL migration script from `docs/supabase-schema.md`
4. Paste into the SQL editor
5. Click "Run" (or press Cmd/Ctrl + Enter)
6. Verify tables were created:
   - Go to **Table Editor**
   - You should see `markets` and `admins` tables

## Step 4: Add Initial Admin

1. Go to **SQL Editor** â†’ **New query**
2. Run this SQL (replace with your admin wallet address):

```sql
INSERT INTO admins (wallet_address) 
VALUES ('aleo1qg23nrrrlf6h7fqq7amk9wqzs06sluh7tm5y6lgg9svpqpck0qqqv9h0sw');
```

3. Verify admin was added:
   - Go to **Table Editor** â†’ `admins` table
   - You should see your wallet address

## Step 5: Configure Environment Variables

Create a `.env` file in the `frontend/` directory:

```env
VITE_SUPABASE_URL=https://xxxxx.supabase.co
VITE_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Important:**
- Use `VITE_` prefix for Vite to expose these to the frontend
- Never commit `.env` file to git (should be in `.gitignore`)
- The `anon` key is safe to expose in frontend code

## Step 6: Test Connection

1. Install Supabase client in frontend:
   ```bash
   cd frontend
   pnpm add @supabase/supabase-js
   ```

2. Test connection (you'll do this in code, but verify credentials work)

## Step 7: Configure Row Level Security (RLS)

For MVP, we'll use a simplified RLS approach:

1. **For markets table:**
   - Public read: Already configured
   - Admin write: Will be handled in application logic (check admin status before allowing writes)

2. **For admins table:**
   - Public read: Already configured
   - Admin write: Will be handled in application logic

**Note:** For production, you may want to implement proper JWT-based authentication with Supabase Auth, but for MVP, we'll handle admin checks in the frontend.

## Troubleshooting

### Migration fails
- Check that UUID extension is enabled
- Verify you have proper permissions
- Check SQL syntax errors in the error message

### Can't see tables
- Refresh the Table Editor
- Check that migration ran successfully (look for success message)

### RLS blocking queries
- For MVP, you can temporarily disable RLS for testing:
  ```sql
  ALTER TABLE markets DISABLE ROW LEVEL SECURITY;
  ALTER TABLE admins DISABLE ROW LEVEL SECURITY;
  ```
- Re-enable when ready:
  ```sql
  ALTER TABLE markets ENABLE ROW LEVEL SECURITY;
  ALTER TABLE admins ENABLE ROW LEVEL SECURITY;
  ```

## Next Steps

After setup is complete:
1. Add Supabase client to frontend (Phase 3)
2. Test creating a market via Supabase
3. Integrate with Aleo smart contracts

## Resources

- [Supabase Documentation](https://supabase.com/docs)
- [Supabase JavaScript Client](https://supabase.com/docs/reference/javascript/introduction)
- [Row Level Security Guide](https://supabase.com/docs/guides/auth/row-level-security)
</file>

<file path="frontend/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="frontend/package.json">
{
  "name": "web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@provablehq/aleo-wallet-adaptor-core": "^0.3.0-alpha.3",
    "@provablehq/aleo-wallet-adaptor-leo": "^0.3.0-alpha.3",
    "@provablehq/aleo-wallet-adaptor-react": "^0.3.0-alpha.3",
    "@provablehq/aleo-wallet-adaptor-react-ui": "^0.3.0-alpha.3",
    "@supabase/supabase-js": "^2.95.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.563.0",
    "next": "16.1.6",
    "next-themes": "^0.4.6",
    "radix-ui": "^1.4.3",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.4.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.1.6",
    "shadcn": "^3.8.4",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.4.0",
    "typescript": "^5"
  }
}
</file>

<file path="frontend/README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="LICENSE.txt">
Private Enterprise Software License
Copyright (c) 2025 Archon Capital
Permission is hereby granted, exclusively to Company Name employees and authorized contractors (â€œAuthorized Usersâ€), to use this software and associated documentation files (the â€œSoftwareâ€) strictly for internal business purposes.
You may not sell, sublicense, distribute, publish, or otherwise disclose the Software or any portion thereof to any third party. Modification, reverse engineering, decompilation, or disassembly of the Software is prohibited except to the extent expressly permitted by applicable law.
The Software is provided â€œAS ISâ€, without warranty of any kind, express or implied, including but not limited to warranties of merchantability, fitness for a particular purpose, or non-infringement. In no event shall Company Name or its authors be liable for any claim, damages, or other liability arising from the use or inability to use the Software.
This license is effective until terminated. It will terminate automatically without notice if you fail to comply with any provision of this license. Upon termination, all rights granted under this license shall cease, and you must destroy all copies of the Software in your possession.
This license gives you a simple, clear, and legally protective basis for private enterprise use, similar in spirit and format to the MIT License, but with the critical restrictions to keep the code confidential and for internal use only.
</file>

<file path="backend/SUPABASE_CLI.md">
# Using Supabase CLI

The Supabase CLI allows you to manage your database from the terminal instead of the web UI.

## Installation

### macOS (Homebrew)
```bash
brew install supabase/tap/supabase
```

### npm (Cross-platform)
```bash
npm install -g supabase
```

```bash
supabase db reset
```

```bash
supabase db push --include-seed
```

### Verify Installation
```bash
supabase --version
```

## Setup

### 1. Login to Supabase
```bash
supabase login
```
This will open your browser to authenticate.

### 2. Link Your Project
```bash
cd frontend
supabase link --project-ref your-project-ref
```

To find your project ref:
- Go to your Supabase project settings
- Look for "Reference ID" or check the URL: `https://supabase.com/dashboard/project/YOUR_PROJECT_REF`

Alternatively, you can link by project ID:
```bash
supabase link --project-id your-project-id
```

### 3. Verify Connection
```bash
supabase status
```

## Running SQL Scripts

### Run Migration
```bash
supabase db push
```
This will run all migrations in the `supabase/migrations` directory.

### Run SQL File Directly
```bash
# Run a specific SQL file
supabase db execute --file supabase-migration.sql

# Or pipe SQL directly
cat supabase-migration.sql | supabase db execute
```

### Run SQL from Terminal
```bash
supabase db execute --sql "SELECT * FROM markets;"
```

## Recommended Workflow

### Option 1: Use Migrations Directory (Recommended)

1. Create migrations directory:
```bash
mkdir -p supabase/migrations
```

2. Copy your migration:
```bash
cp supabase-migration.sql supabase/migrations/20240101000000_initial_schema.sql
```

3. Run migrations:
```bash
supabase db push
```

### Option 2: Direct SQL Execution

Run SQL files directly:
```bash
# Run migration
supabase db execute --file supabase-migration.sql

# Insert test market
supabase db execute --file insert-test-market.sql
```

## Useful Commands

```bash
# Check database status
supabase status

# View database logs
supabase db logs

# Reset database (âš ï¸ destructive)
supabase db reset

# Generate TypeScript types from database
supabase gen types typescript --linked > types/supabase-generated.ts

# Start local Supabase (for local development)
supabase start
```

## Quick Setup Script

You can create a setup script to automate the initial setup:

```bash
#!/bin/bash
# setup-supabase.sh

echo "Running Supabase migration..."
supabase db execute --file supabase-migration.sql

echo "Inserting test market..."
supabase db execute --file insert-test-market.sql

echo "Done! Check your app now."
```

Make it executable:
```bash
chmod +x setup-supabase.sh
./setup-supabase.sh
```
</file>

<file path=".gitignore">
.env
*.avm
*.prover
*.verifier
outputs/
/node_modules
/dist
build/
/coverage
/logs
/tmp
/cache
/backup
/temp
/test
/tests
ai-context/

# Supabase CLI temporary files (created when running supabase start from root)
/supabase/.temp
/supabase/.branches

# Amareleo-chain temporary ledger files
.amareleo-tmp-ledger-*
</file>

<file path="package.json">
{
  "name": "obsidian-market",
  "private": true,
  "scripts": {
    "backend": "cd backend && supabase start",
    "app": "cd frontend && npm run dev",
    "chain": "amareleo-chain start",
    "dev": "run-p backend web"
  },
  "devDependencies": {
    "npm-run-all": "^4.1.5"
  }
}
</file>

<file path="README.md">
# Obsidian Market

[GitHub Repo](https://github.com/adamsimonini/obsidian-market)

A lightweight MVP prediction market application built on Aleo blockchain with cross-platform support (iOS, Android, and Web via React Native/Expo).

[Leo devnet docs](https://docs.leo-lang.org/cli/cli_devnet)
To find SnarkOS Binary
cargo install --list

leo devnet --snarkos /Users/ajsim/.cargo/bin/snarkos
/Users/ajsim/code/snarkOS

leo devnet --snarkos /Users/ajsim/.cargo/bin/snarkos --num-validators 1 --num-clients 0

faucet: https://faucet.aleo.org/

## Overview

Obsidian Market enables users to create and participate in binary (Yes/No) prediction markets. The platform uses Aleo for privacy-preserving transactions and Supabase for market metadata storage.

### Key Features

- **Binary Prediction Markets**: Simple Yes/No markets
- **Fixed Odds Betting**: Admin-set odds for predictable payouts
- **Wallet-Based Authentication**: Leo Wallet integration (web) with manual entry fallback (mobile)
- **Cross-Platform**: Works on iOS, Android, and Web browsers
- **Real-Time Updates**: Supabase real-time subscriptions
- **Admin Controls**: Admin-only market creation and resolution

## Architecture

- **Frontend**: React Native with Expo (cross-platform: iOS, Android, Web)
  - **Styling**: NativeWind v4 (Tailwind CSS for React Native)
  - **UI Components**: NativeWind UI (Button, Card, Input, Text, Icon)
  - **Theme System**: Custom Obsidian theme with light/dark mode support
- **Blockchain**: Aleo smart contracts (Leo language)
- **Database**: Supabase (PostgreSQL with REST API)
- **Authentication**: Leo Wallet (web) / Manual address entry (mobile MVP)

## Getting Started

### Prerequisites

- Node.js >= 18
- pnpm (package manager)
- Expo CLI (installed globally or via npx)
- Supabase account
- Leo CLI (for smart contract development)

### Quick Start

1. **Install Dependencies**

   ```bash
   cd frontend
   pnpm install
   ```

2. **Set Up Environment Variables**

   ```bash
   # Create .env file in frontend/
   EXPO_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
   EXPO_PUBLIC_SUPABASE_ANON_KEY=your-anon-key-here
   ```

3. **Set Up Supabase**
   - Follow [Supabase Quick Setup Guide](./frontend/SUPABASE_SETUP.md)
   - Run the migration script (`supabase-migration.sql`) in Supabase SQL Editor
   - Add your admin wallet address to the `admins` table

4. **Set Up Aleo** (Optional for MVP)
   - Follow [Aleo Local Development Guide](./docs/aleo-local-dev.md)
   - Build and test contracts: `cd aleo && leo build && leo test`

5. **Run Development Server**

   ```bash
   cd frontend
   pnpm start
   ```

   This starts the **Metro bundler** (required for mobile) on port 19000. Then use the interactive menu:
   - Press `i` for iOS simulator
   - Press `a` for Android emulator/Expo Go
   - Press `w` for web browser (starts web dev server on port 19006)
   - Scan QR code with Expo Go app (mobile)

   **Important**: Run `expo start` (or `pnpm start`) without flags to start Metro. Don't use `expo start --web` directly, as it only starts the web server and skips Metro bundler needed for mobile.

## Project Structure

```
obsidian-market/
â”œâ”€â”€ leo/                    # Aleo smart contracts
â”‚   â”œâ”€â”€ src/                # Leo source code
â”‚   â”‚   â””â”€â”€ main.leo        # Main contract
â”‚   â””â”€â”€ tests/              # Contract tests
â”œâ”€â”€ frontend/               # React Native frontend (Expo)
â”‚   â”œâ”€â”€ app/                # Expo Router pages
â”‚   â”œâ”€â”€ components/         # React Native components
â”‚   â”‚   â”œâ”€â”€ nativewindui/   # NativeWind UI components (Text, Card, Icon, ThemeToggle)
â”‚   â”‚   â””â”€â”€ ui/             # Additional UI components (Button, Input, Card)
â”‚   â”œâ”€â”€ contexts/           # React contexts (Wallet)
â”‚   â”œâ”€â”€ hooks/              # Custom hooks
â”‚   â”œâ”€â”€ lib/                # Utilities (Supabase client, useColorScheme)
â”‚   â”œâ”€â”€ theme/              # Theme configuration (colors.ts)
â”‚   â”œâ”€â”€ types/              # TypeScript types
â”‚   â”œâ”€â”€ global.css          # Tailwind CSS directives and CSS variables
â”‚   â”œâ”€â”€ tailwind.config.js  # Tailwind configuration
â”‚   â”œâ”€â”€ supabase-migration.sql  # Database schema
â”‚   â””â”€â”€ SUPABASE_SETUP.md   # Quick setup guide
â”œâ”€â”€ webapp-lynx/            # Legacy Lynx implementation (archived)
â””â”€â”€ docs/                   # Documentation
```

## Documentation

- [Supabase Quick Setup](./frontend/SUPABASE_SETUP.md) - Database setup (start here!)
- [Development Guide](./docs/development.md) - Detailed development setup
- [Deployment Guide](./docs/deployment.md) - Production deployment
- [Supabase Schema](./docs/supabase-schema.md) - Database schema details
- [Aleo Local Development](./docs/aleo-local-dev.md) - Smart contract development
- [Planning Document](./ai-context/planning.md) - Architecture and design decisions

## Technologies

### Frontend Stack

- **React Native**: Cross-platform mobile framework
- **React**: UI library (v19)
- **Expo**: Development platform and tooling
- **Expo Router**: File-based routing
- **NativeWind v4**: Tailwind CSS for React Native - enables utility-first styling with Tailwind classes
- **NativeWind UI**: Pre-built component library with theme support (Button, Card, Input, Text, Icon components)
- **TypeScript**: Type-safe JavaScript

### Backend & Blockchain

- **Aleo/Leo**: Privacy-preserving blockchain
- **Amareleo-Chain**: Lite Aleo development node for local testing (see [Development](#local-aleo-chain) section)
- **Supabase**: Backend-as-a-Service (PostgreSQL + REST API)
- **Leo Wallet Adapter**: Official Aleo wallet integration

## Styling & Theming

The app uses **NativeWind v4** (Tailwind CSS for React Native) for styling and **NativeWind UI** for pre-built components. The styling system includes:

- **Tailwind CSS Classes**: Use utility classes like `bg-background`, `text-foreground`, `border-border` throughout the app
- **NativeWind UI Components**: Pre-built components (`Button`, `Card`, `Input`, `Text`, `Icon`) located in `components/nativewindui/` and `components/ui/`
- **Custom Obsidian Theme**: Custom color palette matching the Obsidian aesthetic
- **Unified Theming**: Single color palette used across all platforms (iOS, Android, Web) for consistent branding
- **Light/Dark Mode**: Full theme switching support with manual toggle

### Theme Architecture

The theming system uses a **unified approach** - the same colors are used across all platforms (iOS, Android, Web) for consistent branding and simplified maintenance.

#### 1. **`theme/colors.ts`** - Primary Source of Truth (React Native)

This is the **single source of truth** for all theme colors used in React Native components.

- **Unified colors**: Single color palette used across all platforms (iOS, Android, Web)
- **Theme variants**: `light` and `dark` theme objects
- **Color tokens**: Semantic color names (background, foreground, primary, border, etc.)
- **Format**: RGB color strings (e.g., `'rgb(242, 242, 247)'`)

**Usage in Components**:

```tsx
import { useColorScheme } from '@/lib/useColorScheme';

function MyComponent() {
  const { colors, colorScheme, toggleColorScheme } = useColorScheme();

  return (
    <View style={{ backgroundColor: colors.background }}>
      <Text style={{ color: colors.foreground }}>Hello</Text>
      <View style={{ borderColor: colors.border }} />
    </View>
  );
}
```

#### 2. **`global.css`** - CSS Variables (Tailwind & Web)

Defines CSS custom properties used by Tailwind CSS classes and web platform styling.

- **Purpose**: Enables Tailwind utilities like `bg-background`, `text-foreground` via `tailwind.config.js`
- **Format**: RGB values without `rgb()` wrapper (e.g., `242 242 247`) for opacity support
- **Unified variables**: Same CSS variables used for all platforms
- **Dark mode**: Supports both `@media (prefers-color-scheme: dark)` and `.dark` class

**How Tailwind Uses It**:
The `tailwind.config.js` uses a `withOpacity()` function that references these CSS variables:

```javascript
// tailwind.config.js
border: withOpacity('border'),  // Uses --border for all platforms
```

#### 3. **`lib/useColorScheme.tsx`** - Theme Hook

Provides a unified interface for accessing theme colors and managing theme state.

- **Wraps**: NativeWind's `useColorScheme` hook
- **Exposes**: `colors` object from `theme/colors.ts` (unified across platforms)
- **Provides**: `colorScheme`, `isDarkColorScheme`, `setColorScheme()`, `toggleColorScheme()`

### Why Two Systems?

React Native doesn't support CSS variables natively, so we need:

1. **Direct RGB values** (`theme/colors.ts`) â†’ For React Native's StyleSheet API
2. **CSS variables** (`global.css`) â†’ For Tailwind utilities and web platform

Both systems should be kept **in sync** when updating theme colors.

### Theme Switching Implementation

The app uses a **hybrid approach** combining Tailwind classes and explicit colors:

#### For Backgrounds & Most Styling

Use Tailwind classes (they work reliably):

```tsx
<View className="bg-background border border-border" />
```

#### For Text Colors & Borders

Use explicit colors from `useColorScheme()` hook (more reliable):

```tsx
const { colors } = useColorScheme();
<Text style={{ color: colors.foreground }} />
<View style={{ borderColor: colors.border }} />
```

**Why This Approach?**

NativeWind's CSS variable resolution can be inconsistent at runtime in React Native, especially for:

- Text colors (`text-foreground` class)
- Border colors (`border-border` class)

By using explicit colors from `useColorScheme()` for these critical properties, we ensure:

- âœ… Immediate theme updates when switching
- âœ… Consistent behavior across platforms
- âœ… Reliable dark mode support

**Components Using Explicit Colors**:

- `components/nativewindui/Text.tsx` - Uses `colors.foreground`
- `components/nativewindui/Card.tsx` - Uses `colors.border`
- `components/ui/card.tsx` - Uses `colors.border`
- `components/ui/input.tsx` - Uses `colors.border` and `colors.mutedForeground`
- `components/ui/button.tsx` - Uses `colors.border` for outline variant
- `components/Header.tsx` - Uses `colors.border` for bottom divider

### Benefits of Unified Theming

The unified theming approach provides several advantages:

- **Consistent Branding**: Same colors across iOS, Android, and Web ensure a cohesive brand experience
- **Simplified Maintenance**: Single color palette means updating colors in one place affects all platforms
- **Easier Development**: No need to manage platform-specific color variations
- **Web Consistency**: Web platform now uses the same colors as mobile, eliminating inconsistencies

### Adding New Theme Colors

1. **Add to `theme/colors.ts`**:

   ```typescript
   // Add to both light and dark theme objects
   const COLORS = {
     light: {
       // ... existing colors ...
       myNewColor: 'rgb(255, 0, 0)',
     },
     dark: {
       // ... existing colors ...
       myNewColor: 'rgb(200, 0, 0)',
     },
   };
   ```

2. **Add to `global.css`**:

   ```css
   :root {
     --my-new-color: 255 0 0;
   }
   .dark {
     --my-new-color: 200 0 0;
   }
   ```

3. **Add to `tailwind.config.js`** (if needed):

   ```javascript
   myNewColor: withOpacity('my-new-color'),
   ```

4. **Use in components**:
   ```tsx
   const { colors } = useColorScheme();
   <View style={{ backgroundColor: colors.myNewColor }} />;
   ```

**Note**: Since we use unified theming, you only need to define each color once (not per platform). The same color will be used across iOS, Android, and Web.

## Development

### Running the App

**Start Metro Bundler (Required for Mobile):**

```bash
cd frontend
pnpm start
```

This starts the Metro bundler on port 19000, which is required for iOS, Android, and Expo Go. Once Metro is running, use the interactive menu:

- Press `i` for iOS simulator
- Press `a` for Android emulator/Expo Go
- Press `w` for web browser (also starts web dev server on port 19006)
- Scan QR code with Expo Go app (mobile)

**Important Notes:**

- âœ… **Correct**: `expo start` or `pnpm start` - Starts Metro bundler, then choose platform
- âŒ **Incorrect**: `expo start --web` - Only starts web server, Metro won't run (Android/iOS won't work)
- The Metro bundler (port 19000) is required for mobile development
- The web dev server (port 19006) is optional and can be started from the Metro menu

### Local Aleo Chain

This project uses [Amareleo-Chain](https://github.com/kaxxa123/amareleo-chain) for local Aleo development. Amareleo-Chain is a lite, developer-friendly Aleo node that provides a minimal validator for testing Aleo program deployment and execution.

**Key Features:**

- Fast startup/shutdown times
- Single process with minimal resource usage
- Fresh chain state by default (or persistent with `--keep-state`)
- Compatible with standard Aleo tools (`snarkOS`, `leo`)

**Available Commands:**

- `amareleo-chain start` - Start the local chain node (exposes REST API on `localhost:3030`)
- `amareleo-chain start --keep-state` - Start with persistent chain state across runs
- `amareleo-chain clean` - Clean the chain storage
- `amareleo-chain update` - Update amareleo-chain

**Package Script:**

```bash
# Start the local Aleo chain
pnpm chain
```

This runs `amareleo-chain start` which starts a fresh chain from genesis and exposes a REST server on [localhost:3030](http://localhost:3030/), supporting the same endpoints as `snarkos`.

### Building

```bash
# iOS
pnpm ios

# Android
pnpm android

# Web
pnpm web
```

### Environment Variables

Create a `.env` file in `frontend/` with:

- `EXPO_PUBLIC_SUPABASE_URL` - Your Supabase project URL
- `EXPO_PUBLIC_SUPABASE_ANON_KEY` - Your Supabase anon key

## License

See [LICENSE.txt](./LICENSE.txt) for details.
</file>

</files>
